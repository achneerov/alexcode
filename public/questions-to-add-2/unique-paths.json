{
  "filename": "unique-paths",
  "title": "Unique Paths",
  "keywords": [
    "unique",
    "paths",
    "grid",
    "robot",
    "dynamic",
    "programming",
    "combinatorics"
  ],
  "description": "<h2>Unique Paths</h2><p>There is a robot on an <code>m x n</code> grid. The robot is initially located at the <strong>top-left corner</strong> (i.e., <code>grid[0][0]</code>). The robot tries to move to the <strong>bottom-right corner</strong> (i.e., <code>grid[m - 1][n - 1]</code>). The robot can only move either down or right at any point in time.</p><p>Given the two integers <code>m</code> and <code>n</code>, return <em>the number of possible unique paths that the robot can take to reach the bottom-right corner</em>.</p><p>The test cases are generated so that the answer will be less than or equal to <code>2 * 10<sup>9</sup></code>.</p><h3>Examples:</h3><ul><li><strong>Example 1:</strong><br>Input: m = 3, n = 7<br>Output: 28</li><li><strong>Example 2:</strong><br>Input: m = 3, n = 2<br>Output: 3<br>Explanation: From the top-left corner, there are a total of 3 ways to reach the bottom-right corner:<br>1. Right -> Down -> Down<br>2. Down -> Down -> Right<br>3. Down -> Right -> Down</li></ul><h3>Constraints:</h3><ul><li>1 <= m, n <= 100</li></ul>",
  "languages": {
    "python": {
      "template": "def uniquePaths(m, n):\n    ",
      "solution_text": "Use DP where dp[i][j] represents number of paths to reach cell (i,j). Each cell can be reached from top or left.",
      "solution_code": "def uniquePaths(m, n):\n    dp = [[1] * n for _ in range(m)]\n    \n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = dp[i-1][j] + dp[i][j-1]\n    \n    return dp[m-1][n-1]"
    },
    "javascript": {
      "template": "function uniquePaths(m, n) {\n  \n}",
      "solution_text": "Use DP where dp[i][j] represents number of paths to reach cell (i,j). Each cell can be reached from top or left.",
      "solution_code": "function uniquePaths(m, n) {\n    const dp = Array(m).fill().map(() => Array(n).fill(1));\n    \n    for (let i = 1; i < m; i++) {\n        for (let j = 1; j < n; j++) {\n            dp[i][j] = dp[i-1][j] + dp[i][j-1];\n        }\n    }\n    \n    return dp[m-1][n-1];\n}"
    },
    "typescript": {
      "template": "function uniquePaths(m: number, n: number): number {\n  \n}",
      "solution_text": "Use DP where dp[i][j] represents number of paths to reach cell (i,j). Each cell can be reached from top or left.",
      "solution_code": "function uniquePaths(m: number, n: number): number {\n    const dp = Array(m).fill(null).map(() => Array(n).fill(1));\n    \n    for (let i = 1; i < m; i++) {\n        for (let j = 1; j < n; j++) {\n            dp[i][j] = dp[i-1][j] + dp[i][j-1];\n        }\n    }\n    \n    return dp[m-1][n-1];\n}"
    },
    "java": {
      "template": "class Solution {\n    public int uniquePaths(int m, int n) {\n        \n    }\n}",
      "solution_text": "Use DP where dp[i][j] represents number of paths to reach cell (i,j). Each cell can be reached from top or left.",
      "solution_code": "class Solution {\n    public int uniquePaths(int m, int n) {\n        int[][] dp = new int[m][n];\n        \n        // Initialize first row and column\n        for (int i = 0; i < m; i++) dp[i][0] = 1;\n        for (int j = 0; j < n; j++) dp[0][j] = 1;\n        \n        for (int i = 1; i < m; i++) {\n            for (int j = 1; j < n; j++) {\n                dp[i][j] = dp[i-1][j] + dp[i][j-1];\n            }\n        }\n        \n        return dp[m-1][n-1];\n    }\n}"
    }
  },
  "order_matters": false,
  "test_cases": [
    {
      "id": 1,
      "input": {
        "m": 3,
        "n": 7
      },
      "output": 28
    },
    {
      "id": 2,
      "input": {
        "m": 3,
        "n": 2
      },
      "output": 3
    },
    {
      "id": 3,
      "input": {
        "m": 1,
        "n": 1
      },
      "output": 1
    }
  ]
}