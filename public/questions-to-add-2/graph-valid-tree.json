{
  "filename": "graph-valid-tree",
  "title": "Graph Valid Tree",
  "keywords": [
    "graph",
    "tree",
    "union",
    "find",
    "dfs",
    "cycle"
  ],
  "description": "<h2>Graph Valid Tree</h2><p>You have a graph of <code>n</code> nodes labeled from <code>0</code> to <code>n - 1</code>. You are given an integer n and a list of <code>edges</code> where <code>edges[i] = [ai, bi]</code> indicates that there is an undirected edge between nodes <code>ai</code> and <code>bi</code> in the graph.</p><p>Return <code>true</code> <em>if the edges of the given graph make up a valid tree, and</em> <code>false</code> <em>otherwise</em>.</p><h3>Examples:</h3><ul><li><strong>Example 1:</strong><br>Input: n = 5, edges = [[0,1],[0,2],[0,3],[1,4]]<br>Output: true</li><li><strong>Example 2:</strong><br>Input: n = 5, edges = [[0,1],[1,2],[2,3],[1,3],[1,4]]<br>Output: false</li></ul><h3>Constraints:</h3><ul><li>1 <= n <= 2000</li><li>0 <= edges.length <= 5000</li><li>edges[i].length == 2</li><li>0 <= ai, bi < n</li><li>ai != bi</li><li>There are no self-loops or repeated edges.</li></ul>",
  "languages": {
    "python": {
      "template": "def validTree(n, edges):\n    ",
      "solution_text": "A valid tree must have exactly n-1 edges and no cycles. Use DFS or Union-Find to detect cycles.",
      "solution_code": "def validTree(n, edges):\n    # A tree with n nodes must have exactly n-1 edges\n    if len(edges) != n - 1:\n        return False\n    \n    # Build adjacency list\n    graph = [[] for _ in range(n)]\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    # DFS to check if all nodes are connected\n    visited = [False] * n\n    \n    def dfs(node):\n        visited[node] = True\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                dfs(neighbor)\n    \n    # Start DFS from node 0\n    dfs(0)\n    \n    # Check if all nodes are visited (connected)\n    return all(visited)"
    },
    "javascript": {
      "template": "function validTree(n, edges) {\n  \n}",
      "solution_text": "A valid tree must have exactly n-1 edges and no cycles. Use DFS or Union-Find to detect cycles.",
      "solution_code": "function validTree(n, edges) {\n    // A tree with n nodes must have exactly n-1 edges\n    if (edges.length !== n - 1) {\n        return false;\n    }\n    \n    // Build adjacency list\n    const graph = Array.from({length: n}, () => []);\n    for (const [u, v] of edges) {\n        graph[u].push(v);\n        graph[v].push(u);\n    }\n    \n    // DFS to check connectivity\n    const visited = new Array(n).fill(false);\n    \n    function dfs(node) {\n        visited[node] = true;\n        for (const neighbor of graph[node]) {\n            if (!visited[neighbor]) {\n                dfs(neighbor);\n            }\n        }\n    }\n    \n    // Start DFS from node 0\n    dfs(0);\n    \n    // Check if all nodes are visited\n    return visited.every(v => v);\n}"
    },
    "typescript": {
      "template": "function validTree(n: number, edges: number[][]): boolean {\n  \n}",
      "solution_text": "A valid tree must have exactly n-1 edges and no cycles. Use DFS or Union-Find to detect cycles.",
      "solution_code": "function validTree(n: number, edges: number[][]): boolean {\n    // A tree with n nodes must have exactly n-1 edges\n    if (edges.length !== n - 1) {\n        return false;\n    }\n    \n    // Build adjacency list\n    const graph: number[][] = Array.from({length: n}, () => []);\n    for (const [u, v] of edges) {\n        graph[u].push(v);\n        graph[v].push(u);\n    }\n    \n    // DFS to check connectivity\n    const visited: boolean[] = new Array(n).fill(false);\n    \n    function dfs(node: number): void {\n        visited[node] = true;\n        for (const neighbor of graph[node]) {\n            if (!visited[neighbor]) {\n                dfs(neighbor);\n            }\n        }\n    }\n    \n    // Start DFS from node 0\n    dfs(0);\n    \n    // Check if all nodes are visited\n    return visited.every(v => v);\n}"
    },
    "java": {
      "template": "class Solution {\n    public boolean validTree(int n, int[][] edges) {\n        \n    }\n}",
      "solution_text": "A valid tree must have exactly n-1 edges and no cycles. Use DFS or Union-Find to detect cycles.",
      "solution_code": "class Solution {\n    public boolean validTree(int n, int[][] edges) {\n        // A tree with n nodes must have exactly n-1 edges\n        if (edges.length != n - 1) {\n            return false;\n        }\n        \n        // Build adjacency list\n        List<List<Integer>> graph = new ArrayList<>();\n        for (int i = 0; i < n; i++) {\n            graph.add(new ArrayList<>());\n        }\n        \n        for (int[] edge : edges) {\n            graph.get(edge[0]).add(edge[1]);\n            graph.get(edge[1]).add(edge[0]);\n        }\n        \n        // DFS to check connectivity\n        boolean[] visited = new boolean[n];\n        dfs(0, graph, visited);\n        \n        // Check if all nodes are visited\n        for (boolean v : visited) {\n            if (!v) return false;\n        }\n        return true;\n    }\n    \n    private void dfs(int node, List<List<Integer>> graph, boolean[] visited) {\n        visited[node] = true;\n        for (int neighbor : graph.get(node)) {\n            if (!visited[neighbor]) {\n                dfs(neighbor, graph, visited);\n            }\n        }\n    }\n}"
    }
  },
  "order_matters": false,
  "test_cases": [
    {
      "id": 1,
      "input": {
        "n": 5,
        "edges": [
          [
            0,
            1
          ],
          [
            0,
            2
          ],
          [
            0,
            3
          ],
          [
            1,
            4
          ]
        ]
      },
      "output": true
    },
    {
      "id": 2,
      "input": {
        "n": 5,
        "edges": [
          [
            0,
            1
          ],
          [
            1,
            2
          ],
          [
            2,
            3
          ],
          [
            1,
            3
          ],
          [
            1,
            4
          ]
        ]
      },
      "output": false
    },
    {
      "id": 3,
      "input": {
        "n": 1,
        "edges": []
      },
      "output": true
    }
  ]
}