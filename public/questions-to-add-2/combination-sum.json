{
  "filename": "combination-sum",
  "title": "Combination Sum",
  "keywords": [
    "combination",
    "sum",
    "backtracking",
    "recursive",
    "target",
    "candidates"
  ],
  "description": "<h2>Combination Sum</h2><p>Given an array of <strong>distinct</strong> integers <code>candidates</code> and a target integer <code>target</code>, return <em>a list of all <strong>unique combinations</strong> of </em><code>candidates</code><em> where the chosen numbers sum to </em><code>target</code><em>.</em> You may return the combinations in <strong>any order</strong>.</p><p>The <strong>same</strong> number may be chosen from <code>candidates</code> an <strong>unlimited number of times</strong>. Two combinations are unique if the frequency of at least one of the chosen numbers is different.</p><p>The test cases are generated such that the number of unique combinations that sum up to <code>target</code> is less than <code>150</code> combinations for the given input.</p><h3>Examples:</h3><ul><li><strong>Example 1:</strong><br>Input: candidates = [2,3,6,7], target = 7<br>Output: [[2,2,3],[7]]<br>Explanation:<br>2 and 3 are candidates, and 2 + 2 + 3 = 7. Note that 2 can be used multiple times.<br>7 is a candidate, and 7 = 7.<br>These are the only two combinations.</li><li><strong>Example 2:</strong><br>Input: candidates = [2,3,5], target = 8<br>Output: [[2,2,2,2],[2,3,3],[3,5]]</li><li><strong>Example 3:</strong><br>Input: candidates = [2], target = 1<br>Output: []</li></ul><h3>Constraints:</h3><ul><li>1 <= candidates.length <= 30</li><li>2 <= candidates[i] <= 40</li><li>All elements of candidates are <strong>distinct</strong>.</li><li>1 <= target <= 40</li></ul>",
  "languages": {
    "python": {
      "template": "def combinationSum(candidates, target):\n    ",
      "solution_text": "Use backtracking to explore all possible combinations. For each candidate, try including it multiple times until target is exceeded.",
      "solution_code": "def combinationSum(candidates, target):\n    result = []\n    \n    def backtrack(remaining, combination, start):\n        if remaining == 0:\n            result.append(combination[:])\n            return\n        \n        for i in range(start, len(candidates)):\n            if candidates[i] <= remaining:\n                combination.append(candidates[i])\n                backtrack(remaining - candidates[i], combination, i)\n                combination.pop()\n    \n    backtrack(target, [], 0)\n    return result"
    },
    "javascript": {
      "template": "function combinationSum(candidates, target) {\n  \n}",
      "solution_text": "Use backtracking to explore all possible combinations. For each candidate, try including it multiple times until target is exceeded.",
      "solution_code": "function combinationSum(candidates, target) {\n    const result = [];\n    \n    function backtrack(remaining, combination, start) {\n        if (remaining === 0) {\n            result.push([...combination]);\n            return;\n        }\n        \n        for (let i = start; i < candidates.length; i++) {\n            if (candidates[i] <= remaining) {\n                combination.push(candidates[i]);\n                backtrack(remaining - candidates[i], combination, i);\n                combination.pop();\n            }\n        }\n    }\n    \n    backtrack(target, [], 0);\n    return result;\n}"
    },
    "typescript": {
      "template": "function combinationSum(candidates: number[], target: number): number[][] {\n  \n}",
      "solution_text": "Use backtracking to explore all possible combinations. For each candidate, try including it multiple times until target is exceeded.",
      "solution_code": "function combinationSum(candidates: number[], target: number): number[][] {\n    const result: number[][] = [];\n    \n    function backtrack(remaining: number, combination: number[], start: number): void {\n        if (remaining === 0) {\n            result.push([...combination]);\n            return;\n        }\n        \n        for (let i = start; i < candidates.length; i++) {\n            if (candidates[i] <= remaining) {\n                combination.push(candidates[i]);\n                backtrack(remaining - candidates[i], combination, i);\n                combination.pop();\n            }\n        }\n    }\n    \n    backtrack(target, [], 0);\n    return result;\n}"
    },
    "java": {
      "template": "class Solution {\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\n        \n    }\n}",
      "solution_text": "Use backtracking to explore all possible combinations. For each candidate, try including it multiple times until target is exceeded.",
      "solution_code": "class Solution {\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\n        List<List<Integer>> result = new ArrayList<>();\n        backtrack(candidates, target, new ArrayList<>(), 0, result);\n        return result;\n    }\n    \n    private void backtrack(int[] candidates, int remaining, List<Integer> combination, int start, List<List<Integer>> result) {\n        if (remaining == 0) {\n            result.add(new ArrayList<>(combination));\n            return;\n        }\n        \n        for (int i = start; i < candidates.length; i++) {\n            if (candidates[i] <= remaining) {\n                combination.add(candidates[i]);\n                backtrack(candidates, remaining - candidates[i], combination, i, result);\n                combination.remove(combination.size() - 1);\n            }\n        }\n    }\n}"
    }
  },
  "order_matters": false,
  "test_cases": [
    {
      "id": 1,
      "input": {
        "candidates": [
          2,
          3,
          6,
          7
        ],
        "target": 7
      },
      "output": [
        [
          2,
          2,
          3
        ],
        [
          7
        ]
      ]
    },
    {
      "id": 2,
      "input": {
        "candidates": [
          2,
          3,
          5
        ],
        "target": 8
      },
      "output": [
        [
          2,
          2,
          2,
          2
        ],
        [
          2,
          3,
          3
        ],
        [
          3,
          5
        ]
      ]
    },
    {
      "id": 3,
      "input": {
        "candidates": [
          2
        ],
        "target": 1
      },
      "output": []
    }
  ]
}