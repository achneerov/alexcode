{
  "filename": "meeting-rooms-ii",
  "title": "Meeting Rooms II",
  "keywords": [
    "meeting",
    "rooms",
    "intervals",
    "heap",
    "scheduling",
    "priority"
  ],
  "description": "<h2>Meeting Rooms II</h2><p>Given an array of meeting time intervals <code>intervals</code> where <code>intervals[i] = [starti, endi]</code>, return <em>the minimum number of conference rooms required</em>.</p><h3>Examples:</h3><ul><li><strong>Example 1:</strong><br>Input: intervals = [[0,30],[5,10],[15,20]]<br>Output: 2</li><li><strong>Example 2:</strong><br>Input: intervals = [[7,10],[2,4]]<br>Output: 1</li></ul><h3>Constraints:</h3><ul><li>1 <= intervals.length <= 10^4</li><li>0 <= starti < endi <= 10^6</li></ul>",
  "languages": {
    "python": {
      "template": "def minMeetingRooms(intervals):\n    ",
      "solution_text": "Use a min-heap to track end times of ongoing meetings. Sort intervals by start time.",
      "solution_code": "def minMeetingRooms(intervals):\n    if not intervals:\n        return 0\n    \n    import heapq\n    \n    # Sort intervals by start time\n    intervals.sort(key=lambda x: x[0])\n    \n    # Min heap to track end times of ongoing meetings\n    heap = []\n    \n    for start, end in intervals:\n        # If the earliest ending meeting has ended, remove it\n        if heap and heap[0] <= start:\n            heapq.heappop(heap)\n        \n        # Add current meeting's end time\n        heapq.heappush(heap, end)\n    \n    # Number of rooms needed is the size of heap\n    return len(heap)"
    },
    "javascript": {
      "template": "function minMeetingRooms(intervals) {\n  \n}",
      "solution_text": "Use a min-heap to track end times of ongoing meetings. Sort intervals by start time.",
      "solution_code": "function minMeetingRooms(intervals) {\n    if (intervals.length === 0) return 0;\n    \n    // Sort intervals by start time\n    intervals.sort((a, b) => a[0] - b[0]);\n    \n    // Array to track end times (acts as min heap)\n    const endTimes = [];\n    \n    for (const [start, end] of intervals) {\n        // Remove meetings that have ended\n        for (let i = endTimes.length - 1; i >= 0; i--) {\n            if (endTimes[i] <= start) {\n                endTimes.splice(i, 1);\n                break;\n            }\n        }\n        \n        // Add current meeting's end time and keep sorted\n        endTimes.push(end);\n        endTimes.sort((a, b) => a - b);\n    }\n    \n    return endTimes.length;\n}"
    },
    "typescript": {
      "template": "function minMeetingRooms(intervals: number[][]): number {\n  \n}",
      "solution_text": "Use a min-heap to track end times of ongoing meetings. Sort intervals by start time.",
      "solution_code": "function minMeetingRooms(intervals: number[][]): number {\n    if (intervals.length === 0) return 0;\n    \n    // Sort intervals by start time\n    intervals.sort((a, b) => a[0] - b[0]);\n    \n    // Array to track end times (acts as min heap)\n    const endTimes: number[] = [];\n    \n    for (const [start, end] of intervals) {\n        // Remove meetings that have ended\n        for (let i = endTimes.length - 1; i >= 0; i--) {\n            if (endTimes[i] <= start) {\n                endTimes.splice(i, 1);\n                break;\n            }\n        }\n        \n        // Add current meeting's end time and keep sorted\n        endTimes.push(end);\n        endTimes.sort((a, b) => a - b);\n    }\n    \n    return endTimes.length;\n}"
    },
    "java": {
      "template": "class Solution {\n    public int minMeetingRooms(int[][] intervals) {\n        \n    }\n}",
      "solution_text": "Use a min-heap to track end times of ongoing meetings. Sort intervals by start time.",
      "solution_code": "class Solution {\n    public int minMeetingRooms(int[][] intervals) {\n        if (intervals.length == 0) return 0;\n        \n        // Sort intervals by start time\n        Arrays.sort(intervals, (a, b) -> a[0] - b[0]);\n        \n        // Min heap to track end times\n        PriorityQueue<Integer> heap = new PriorityQueue<>();\n        \n        for (int[] interval : intervals) {\n            // If the earliest ending meeting has ended, remove it\n            if (!heap.isEmpty() && heap.peek() <= interval[0]) {\n                heap.poll();\n            }\n            \n            // Add current meeting's end time\n            heap.offer(interval[1]);\n        }\n        \n        return heap.size();\n    }\n}"
    }
  },
  "order_matters": false,
  "test_cases": [
    {
      "id": 1,
      "input": {
        "intervals": [
          [
            0,
            30
          ],
          [
            5,
            10
          ],
          [
            15,
            20
          ]
        ]
      },
      "output": 2
    },
    {
      "id": 2,
      "input": {
        "intervals": [
          [
            7,
            10
          ],
          [
            2,
            4
          ]
        ]
      },
      "output": 1
    },
    {
      "id": 3,
      "input": {
        "intervals": [
          [
            9,
            10
          ],
          [
            4,
            9
          ],
          [
            4,
            17
          ]
        ]
      },
      "output": 2
    }
  ]
}