{
  "filename": "search-in-rotated-sorted-array",
  "title": "Search in Rotated Sorted Array",
  "keywords": [
    "search",
    "rotated",
    "sorted",
    "array",
    "binary",
    "target",
    "pivot"
  ],
  "description": "<h2>Search in Rotated Sorted Array</h2><p>There is an integer array <code>nums</code> sorted in ascending order (with distinct values).</p><p>Prior to being passed to your function, <code>nums</code> is possibly rotated at an unknown pivot index <code>k</code> (1 <= k < nums.length) such that the resulting array is <code>[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]</code> (0-indexed). For example, <code>[0,1,2,4,5,6,7]</code> might be rotated at pivot index <code>3</code> and become <code>[4,5,6,7,0,1,2]</code>.</p><p>Given the array <code>nums</code> after the possible rotation and an integer <code>target</code>, return the index of <code>target</code> if it is in the array, or <code>-1</code> if it is not in the array.</p><p>You must write an algorithm with O(log n) runtime complexity.</p><h3>Examples:</h3><ul><li><strong>Example 1:</strong><br>Input: nums = [4,5,6,7,0,1,2], target = 0<br>Output: 4</li><li><strong>Example 2:</strong><br>Input: nums = [4,5,6,7,0,1,2], target = 3<br>Output: -1</li><li><strong>Example 3:</strong><br>Input: nums = [1], target = 0<br>Output: -1</li></ul><h3>Constraints:</h3><ul><li>1 <= nums.length <= 5000</li><li>-10<sup>4</sup> <= nums[i] <= 10<sup>4</sup></li><li>All values of nums are unique.</li><li>nums is an ascending array that is possibly rotated.</li><li>-10<sup>4</sup> <= target <= 10<sup>4</sup></li></ul>",
  "languages": {
    "python": {
      "template": "def search(nums, target):\n    ",
      "solution_text": "Use binary search with rotation logic. Check which half is sorted and search accordingly.",
      "solution_code": "def search(nums, target):\n    left, right = 0, len(nums) - 1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        \n        if nums[mid] == target:\n            return mid\n        \n        # Left half is sorted\n        if nums[left] <= nums[mid]:\n            if nums[left] <= target < nums[mid]:\n                right = mid - 1\n            else:\n                left = mid + 1\n        # Right half is sorted\n        else:\n            if nums[mid] < target <= nums[right]:\n                left = mid + 1\n            else:\n                right = mid - 1\n    \n    return -1"
    },
    "javascript": {
      "template": "function search(nums, target) {\n  \n}",
      "solution_text": "Use binary search with rotation logic. Check which half is sorted and search accordingly.",
      "solution_code": "function search(nums, target) {\n    let left = 0;\n    let right = nums.length - 1;\n    \n    while (left <= right) {\n        const mid = Math.floor((left + right) / 2);\n        \n        if (nums[mid] === target) {\n            return mid;\n        }\n        \n        // Left half is sorted\n        if (nums[left] <= nums[mid]) {\n            if (nums[left] <= target && target < nums[mid]) {\n                right = mid - 1;\n            } else {\n                left = mid + 1;\n            }\n        }\n        // Right half is sorted\n        else {\n            if (nums[mid] < target && target <= nums[right]) {\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n    }\n    \n    return -1;\n}"
    },
    "typescript": {
      "template": "function search(nums: number[], target: number): number {\n  \n}",
      "solution_text": "Use binary search with rotation logic. Check which half is sorted and search accordingly.",
      "solution_code": "function search(nums: number[], target: number): number {\n    let left = 0;\n    let right = nums.length - 1;\n    \n    while (left <= right) {\n        const mid = Math.floor((left + right) / 2);\n        \n        if (nums[mid] === target) {\n            return mid;\n        }\n        \n        // Left half is sorted\n        if (nums[left] <= nums[mid]) {\n            if (nums[left] <= target && target < nums[mid]) {\n                right = mid - 1;\n            } else {\n                left = mid + 1;\n            }\n        }\n        // Right half is sorted\n        else {\n            if (nums[mid] < target && target <= nums[right]) {\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n    }\n    \n    return -1;\n}"
    },
    "java": {
      "template": "class Solution {\n    public int search(int[] nums, int target) {\n        \n    }\n}",
      "solution_text": "Use binary search with rotation logic. Check which half is sorted and search accordingly.",
      "solution_code": "class Solution {\n    public int search(int[] nums, int target) {\n        int left = 0;\n        int right = nums.length - 1;\n        \n        while (left <= right) {\n            int mid = left + (right - left) / 2;\n            \n            if (nums[mid] == target) {\n                return mid;\n            }\n            \n            // Left half is sorted\n            if (nums[left] <= nums[mid]) {\n                if (nums[left] <= target && target < nums[mid]) {\n                    right = mid - 1;\n                } else {\n                    left = mid + 1;\n                }\n            }\n            // Right half is sorted\n            else {\n                if (nums[mid] < target && target <= nums[right]) {\n                    left = mid + 1;\n                } else {\n                    right = mid - 1;\n                }\n            }\n        }\n        \n        return -1;\n    }\n}"
    }
  },
  "order_matters": false,
  "test_cases": [
    {
      "id": 1,
      "input": {
        "nums": [
          4,
          5,
          6,
          7,
          0,
          1,
          2
        ],
        "target": 0
      },
      "output": 4
    },
    {
      "id": 2,
      "input": {
        "nums": [
          4,
          5,
          6,
          7,
          0,
          1,
          2
        ],
        "target": 3
      },
      "output": -1
    },
    {
      "id": 3,
      "input": {
        "nums": [
          1
        ],
        "target": 0
      },
      "output": -1
    }
  ]
}