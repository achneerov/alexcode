{
  "filename": "non-overlapping-intervals",
  "title": "Non-overlapping Intervals",
  "keywords": [
    "intervals",
    "greedy",
    "sorting",
    "non-overlapping",
    "remove"
  ],
  "description": "<h2>Non-overlapping Intervals</h2><p>Given an array of intervals <code>intervals</code> where <code>intervals[i] = [starti, endi]</code>, return <em>the minimum number of intervals you need to remove to make the rest of the intervals non-overlapping</em>.</p><h3>Examples:</h3><ul><li><strong>Example 1:</strong><br>Input: intervals = [[1,2],[2,3],[3,4],[1,3]]<br>Output: 1<br>Explanation: [1,3] can be removed and the rest of the intervals are non-overlapping.</li><li><strong>Example 2:</strong><br>Input: intervals = [[1,2],[1,2],[1,2]]<br>Output: 2<br>Explanation: You need to remove two [1,2] to make the rest of the intervals non-overlapping.</li></ul><h3>Constraints:</h3><ul><li>1 <= intervals.length <= 10^5</li><li>intervals[i].length == 2</li><li>-5 * 10^4 <= starti < endi <= 5 * 10^4</li></ul>",
  "languages": {
    "python": {
      "template": "def eraseOverlapIntervals(intervals):\n    ",
      "solution_text": "Sort by end time and use greedy approach to keep intervals with earliest end times.",
      "solution_code": "def eraseOverlapIntervals(intervals):\n    if not intervals:\n        return 0\n    \n    # Sort by end time\n    intervals.sort(key=lambda x: x[1])\n    \n    count = 0\n    prevEnd = intervals[0][1]\n    \n    for i in range(1, len(intervals)):\n        # If current interval overlaps with previous\n        if intervals[i][0] < prevEnd:\n            count += 1  # Remove current interval\n        else:\n            prevEnd = intervals[i][1]  # Update end time\n    \n    return count"
    },
    "javascript": {
      "template": "function eraseOverlapIntervals(intervals) {\n  \n}",
      "solution_text": "Sort by end time and use greedy approach to keep intervals with earliest end times.",
      "solution_code": "function eraseOverlapIntervals(intervals) {\n    if (intervals.length === 0) return 0;\n    \n    // Sort by end time\n    intervals.sort((a, b) => a[1] - b[1]);\n    \n    let count = 0;\n    let prevEnd = intervals[0][1];\n    \n    for (let i = 1; i < intervals.length; i++) {\n        // If current interval overlaps with previous\n        if (intervals[i][0] < prevEnd) {\n            count++; // Remove current interval\n        } else {\n            prevEnd = intervals[i][1]; // Update end time\n        }\n    }\n    \n    return count;\n}"
    },
    "typescript": {
      "template": "function eraseOverlapIntervals(intervals: number[][]): number {\n  \n}",
      "solution_text": "Sort by end time and use greedy approach to keep intervals with earliest end times.",
      "solution_code": "function eraseOverlapIntervals(intervals: number[][]): number {\n    if (intervals.length === 0) return 0;\n    \n    // Sort by end time\n    intervals.sort((a, b) => a[1] - b[1]);\n    \n    let count = 0;\n    let prevEnd = intervals[0][1];\n    \n    for (let i = 1; i < intervals.length; i++) {\n        // If current interval overlaps with previous\n        if (intervals[i][0] < prevEnd) {\n            count++; // Remove current interval\n        } else {\n            prevEnd = intervals[i][1]; // Update end time\n        }\n    }\n    \n    return count;\n}"
    },
    "java": {
      "template": "class Solution {\n    public int eraseOverlapIntervals(int[][] intervals) {\n        \n    }\n}",
      "solution_text": "Sort by end time and use greedy approach to keep intervals with earliest end times.",
      "solution_code": "class Solution {\n    public int eraseOverlapIntervals(int[][] intervals) {\n        if (intervals.length == 0) return 0;\n        \n        // Sort by end time\n        Arrays.sort(intervals, (a, b) -> a[1] - b[1]);\n        \n        int count = 0;\n        int prevEnd = intervals[0][1];\n        \n        for (int i = 1; i < intervals.length; i++) {\n            // If current interval overlaps with previous\n            if (intervals[i][0] < prevEnd) {\n                count++; // Remove current interval\n            } else {\n                prevEnd = intervals[i][1]; // Update end time\n            }\n        }\n        \n        return count;\n    }\n}"
    }
  },
  "order_matters": false,
  "test_cases": [
    {
      "id": 1,
      "input": {
        "intervals": [
          [
            1,
            2
          ],
          [
            2,
            3
          ],
          [
            3,
            4
          ],
          [
            1,
            3
          ]
        ]
      },
      "output": 1
    },
    {
      "id": 2,
      "input": {
        "intervals": [
          [
            1,
            2
          ],
          [
            1,
            2
          ],
          [
            1,
            2
          ]
        ]
      },
      "output": 2
    },
    {
      "id": 3,
      "input": {
        "intervals": [
          [
            1,
            2
          ],
          [
            2,
            3
          ]
        ]
      },
      "output": 0
    }
  ]
}