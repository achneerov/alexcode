{
  "filename": "pacific-atlantic-water-flow",
  "title": "Pacific Atlantic Water Flow",
  "keywords": [
    "pacific",
    "atlantic",
    "water",
    "flow",
    "dfs",
    "grid",
    "matrix"
  ],
  "description": "<h2>Pacific Atlantic Water Flow</h2><p>There is an <code>m x n</code> rectangular island that borders both the <strong>Pacific Ocean</strong> and <strong>Atlantic Ocean</strong>. The <strong>Pacific Ocean</strong> touches the island's left and top edges, and the <strong>Atlantic Ocean</strong> touches the island's right and bottom edges.</p><p>The island is partitioned into a grid of square cells. You are given an <code>m x n</code> integer matrix <code>heights</code> where <code>heights[r][c]</code> represents the <strong>height above sea level</strong> of the cell at coordinate <code>(r, c)</code>.</p><p>The island receives a lot of rain, and the rain water can flow to neighboring cells directly north, south, east, and west if the neighboring cell's height is <strong>less than or equal to</strong> the current cell's height. Water can flow from any cell adjacent to an ocean into the ocean.</p><p>Return <em>a <strong>2D list</strong> of grid coordinates </em><code>result</code><em> where </em><code>result[i] = [r<sub>i</sub>, c<sub>i</sub>]</code><em> denotes that rain water can flow from cell </em><code>(r<sub>i</sub>, c<sub>i</sub>)</code><em> to <strong>both</strong> the Pacific and Atlantic oceans</em>.</p><h3>Examples:</h3><ul><li><strong>Example 1:</strong><br>Input: heights = [[1,2,2,3,5],[3,2,3,4,4],[2,4,5,3,1],[6,7,1,4,5],[5,1,1,2,4]]<br>Output: [[0,4],[1,3],[1,4],[2,2],[3,0],[3,1],[4,0]]<br>Explanation: The following cells can flow to the Pacific and Atlantic oceans, as shown below:<br>[0,4]: [0,4] -> Pacific Ocean <br>       [0,4] -> Atlantic Ocean<br>[1,3]: [1,3] -> [0,3] -> Pacific Ocean <br>       [1,3] -> [1,4] -> Atlantic Ocean<br>[1,4]: [1,4] -> [1,3] -> [0,3] -> Pacific Ocean <br>       [1,4] -> Atlantic Ocean<br>[2,2]: [2,2] -> [1,2] -> [0,2] -> Pacific Ocean <br>       [2,2] -> [2,3] -> [2,4] -> Atlantic Ocean<br>[3,0]: [3,0] -> Pacific Ocean <br>       [3,0] -> [4,0] -> Atlantic Ocean<br>[3,1]: [3,1] -> [3,0] -> Pacific Ocean <br>       [3,1] -> [4,1] -> Atlantic Ocean<br>[4,0]: [4,0] -> Pacific Ocean <br>       [4,0] -> Atlantic Ocean<br>Note that there are other possible paths for these cells to flow to the Pacific and Atlantic oceans.</li><li><strong>Example 2:</strong><br>Input: heights = [[1]]<br>Output: [[0,0]]<br>Explanation: The water can flow from the only cell to the Pacific and Atlantic oceans.</li></ul><h3>Constraints:</h3><ul><li>m == heights.length</li><li>n == heights[r].length</li><li>1 <= m, n <= 200</li><li>0 <= heights[r][c] <= 10<sup>5</sup></li></ul>",
  "languages": {
    "python": {
      "template": "def pacificAtlantic(heights):\n    ",
      "solution_text": "Use DFS from ocean borders inward. Find cells reachable from both Pacific and Atlantic borders.",
      "solution_code": "def pacificAtlantic(heights):\n    if not heights or not heights[0]:\n        return []\n    \n    rows, cols = len(heights), len(heights[0])\n    pacific = set()\n    atlantic = set()\n    \n    def dfs(r, c, visited, prev_height):\n        if (r < 0 or r >= rows or c < 0 or c >= cols or \n            (r, c) in visited or heights[r][c] < prev_height):\n            return\n        \n        visited.add((r, c))\n        \n        # Explore all 4 directions\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            dfs(r + dr, c + dc, visited, heights[r][c])\n    \n    # DFS from Pacific borders (top and left)\n    for r in range(rows):\n        dfs(r, 0, pacific, heights[r][0])\n        dfs(r, cols - 1, atlantic, heights[r][cols - 1])\n    \n    for c in range(cols):\n        dfs(0, c, pacific, heights[0][c])\n        dfs(rows - 1, c, atlantic, heights[rows - 1][c])\n    \n    return list(pacific & atlantic)"
    },
    "javascript": {
      "template": "function pacificAtlantic(heights) {\n  \n}",
      "solution_text": "Use DFS from ocean borders inward. Find cells reachable from both Pacific and Atlantic borders.",
      "solution_code": "function pacificAtlantic(heights) {\n    if (!heights || !heights[0]) return [];\n    \n    const rows = heights.length;\n    const cols = heights[0].length;\n    const pacific = new Set();\n    const atlantic = new Set();\n    \n    function dfs(r, c, visited, prevHeight) {\n        const key = `${r},${c}`;\n        if (r < 0 || r >= rows || c < 0 || c >= cols || \n            visited.has(key) || heights[r][c] < prevHeight) {\n            return;\n        }\n        \n        visited.add(key);\n        \n        // Explore all 4 directions\n        const directions = [[0, 1], [0, -1], [1, 0], [-1, 0]];\n        for (const [dr, dc] of directions) {\n            dfs(r + dr, c + dc, visited, heights[r][c]);\n        }\n    }\n    \n    // DFS from Pacific borders (top and left)\n    for (let r = 0; r < rows; r++) {\n        dfs(r, 0, pacific, heights[r][0]);\n        dfs(r, cols - 1, atlantic, heights[r][cols - 1]);\n    }\n    \n    for (let c = 0; c < cols; c++) {\n        dfs(0, c, pacific, heights[0][c]);\n        dfs(rows - 1, c, atlantic, heights[rows - 1][c]);\n    }\n    \n    const result = [];\n    for (const cell of pacific) {\n        if (atlantic.has(cell)) {\n            const [r, c] = cell.split(',').map(Number);\n            result.push([r, c]);\n        }\n    }\n    \n    return result;\n}"
    },
    "typescript": {
      "template": "function pacificAtlantic(heights: number[][]): number[][] {\n  \n}",
      "solution_text": "Use DFS from ocean borders inward. Find cells reachable from both Pacific and Atlantic borders.",
      "solution_code": "function pacificAtlantic(heights: number[][]): number[][] {\n    if (!heights || !heights[0]) return [];\n    \n    const rows = heights.length;\n    const cols = heights[0].length;\n    const pacific = new Set<string>();\n    const atlantic = new Set<string>();\n    \n    function dfs(r: number, c: number, visited: Set<string>, prevHeight: number): void {\n        const key = `${r},${c}`;\n        if (r < 0 || r >= rows || c < 0 || c >= cols || \n            visited.has(key) || heights[r][c] < prevHeight) {\n            return;\n        }\n        \n        visited.add(key);\n        \n        // Explore all 4 directions\n        const directions = [[0, 1], [0, -1], [1, 0], [-1, 0]];\n        for (const [dr, dc] of directions) {\n            dfs(r + dr, c + dc, visited, heights[r][c]);\n        }\n    }\n    \n    // DFS from Pacific borders (top and left)\n    for (let r = 0; r < rows; r++) {\n        dfs(r, 0, pacific, heights[r][0]);\n        dfs(r, cols - 1, atlantic, heights[r][cols - 1]);\n    }\n    \n    for (let c = 0; c < cols; c++) {\n        dfs(0, c, pacific, heights[0][c]);\n        dfs(rows - 1, c, atlantic, heights[rows - 1][c]);\n    }\n    \n    const result: number[][] = [];\n    for (const cell of pacific) {\n        if (atlantic.has(cell)) {\n            const [r, c] = cell.split(',').map(Number);\n            result.push([r, c]);\n        }\n    }\n    \n    return result;\n}"
    },
    "java": {
      "template": "class Solution {\n    public List<List<Integer>> pacificAtlantic(int[][] heights) {\n        \n    }\n}",
      "solution_text": "Use DFS from ocean borders inward. Find cells reachable from both Pacific and Atlantic borders.",
      "solution_code": "class Solution {\n    public List<List<Integer>> pacificAtlantic(int[][] heights) {\n        if (heights == null || heights.length == 0) return new ArrayList<>();\n        \n        int rows = heights.length;\n        int cols = heights[0].length;\n        boolean[][] pacific = new boolean[rows][cols];\n        boolean[][] atlantic = new boolean[rows][cols];\n        \n        // DFS from Pacific borders (top and left)\n        for (int r = 0; r < rows; r++) {\n            dfs(heights, r, 0, pacific, heights[r][0]);\n            dfs(heights, r, cols - 1, atlantic, heights[r][cols - 1]);\n        }\n        \n        for (int c = 0; c < cols; c++) {\n            dfs(heights, 0, c, pacific, heights[0][c]);\n            dfs(heights, rows - 1, c, atlantic, heights[rows - 1][c]);\n        }\n        \n        List<List<Integer>> result = new ArrayList<>();\n        for (int r = 0; r < rows; r++) {\n            for (int c = 0; c < cols; c++) {\n                if (pacific[r][c] && atlantic[r][c]) {\n                    result.add(Arrays.asList(r, c));\n                }\n            }\n        }\n        \n        return result;\n    }\n    \n    private void dfs(int[][] heights, int r, int c, boolean[][] visited, int prevHeight) {\n        if (r < 0 || r >= heights.length || c < 0 || c >= heights[0].length || \n            visited[r][c] || heights[r][c] < prevHeight) {\n            return;\n        }\n        \n        visited[r][c] = true;\n        \n        // Explore all 4 directions\n        dfs(heights, r + 1, c, visited, heights[r][c]);\n        dfs(heights, r - 1, c, visited, heights[r][c]);\n        dfs(heights, r, c + 1, visited, heights[r][c]);\n        dfs(heights, r, c - 1, visited, heights[r][c]);\n    }\n}"
    }
  },
  "order_matters": false,
  "test_cases": [
    {
      "id": 1,
      "input": {
        "heights": [
          [
            1,
            2,
            2,
            3,
            5
          ],
          [
            3,
            2,
            3,
            4,
            4
          ],
          [
            2,
            4,
            5,
            3,
            1
          ],
          [
            6,
            7,
            1,
            4,
            5
          ],
          [
            5,
            1,
            1,
            2,
            4
          ]
        ]
      },
      "output": [
        [
          0,
          4
        ],
        [
          1,
          3
        ],
        [
          1,
          4
        ],
        [
          2,
          2
        ],
        [
          3,
          0
        ],
        [
          3,
          1
        ],
        [
          4,
          0
        ]
      ]
    },
    {
      "id": 2,
      "input": {
        "heights": [
          [
            1
          ]
        ]
      },
      "output": [
        [
          0,
          0
        ]
      ]
    }
  ]
}