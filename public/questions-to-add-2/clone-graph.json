{
  "filename": "clone-graph",
  "title": "Clone Graph",
  "keywords": [
    "clone",
    "graph",
    "deep",
    "copy",
    "dfs",
    "bfs",
    "hashmap"
  ],
  "description": "<h2>Clone Graph</h2><p>Given a reference of a node in a <strong>connected</strong> undirected graph.</p><p>Return a <strong>deep copy</strong> (clone) of the graph.</p><p>Each node in the graph contains a value (<code>int</code>) and a list (<code>List[Node]</code>) of its neighbors.</p><pre>class Node {\n    public int val;\n    public List&lt;Node&gt; neighbors;\n}</pre><h3>Test case format:</h3><p>For simplicity, each node's value is the same as the node's index (1-indexed). For example, the first node with <code>val == 1</code>, the second node with <code>val == 2</code>, and so on. The graph is represented in the test case using an adjacency list.</p><p><strong>An adjacency list</strong> is a collection of unordered <strong>lists</strong> used to represent a finite graph. Each list describes the set of neighbors of a node in the graph.</p><p>The given node will always be the first node with <code>val = 1</code>. You must return the <strong>copy of the given node</strong> as a reference to the cloned graph.</p><h3>Examples:</h3><ul><li><strong>Example 1:</strong><br>Input: adjList = [[2,4],[1,3],[2,4],[1,3]]<br>Output: [[2,4],[1,3],[2,4],[1,3]]<br>Explanation: There are 4 nodes in the graph.<br>1st node (val = 1)'s neighbors are 2nd node (val = 2) and 4th node (val = 4).<br>2nd node (val = 2)'s neighbors are 1st node (val = 1) and 3rd node (val = 3).<br>3rd node (val = 3)'s neighbors are 2nd node (val = 2) and 4th node (val = 4).<br>4th node (val = 4)'s neighbors are 1st node (val = 1) and 3rd node (val = 3).</li><li><strong>Example 2:</strong><br>Input: adjList = [[]]<br>Output: [[]]<br>Explanation: Note that the input contains one empty list. The graph consists of only one node with val = 1 and it does not have any neighbors.</li><li><strong>Example 3:</strong><br>Input: adjList = []<br>Output: []<br>Explanation: This an empty graph, it does not have any nodes.</li></ul><h3>Constraints:</h3><ul><li>The number of nodes in the graph is in the range [0, 100].</li><li>1 <= Node.val <= 100</li><li>Node.val is unique for each node.</li><li>There are no repeated edges and no self-loops in the graph.</li><li>The Graph is connected and all nodes can be visited starting from the given node.</li></ul>",
  "languages": {
    "python": {
      "template": "def cloneGraph(node):\n    ",
      "solution_text": "Use DFS with hash map to track visited nodes and their clones. Create new nodes and recursively clone neighbors.",
      "solution_code": "def cloneGraph(node):\n    if not node:\n        return None\n    \n    cloned = {}\n    \n    def dfs(node):\n        if node in cloned:\n            return cloned[node]\n        \n        # Create clone\n        clone = Node(node.val)\n        cloned[node] = clone\n        \n        # Clone all neighbors\n        for neighbor in node.neighbors:\n            clone.neighbors.append(dfs(neighbor))\n        \n        return clone\n    \n    return dfs(node)"
    },
    "javascript": {
      "template": "function cloneGraph(node) {\n  \n}",
      "solution_text": "Use DFS with hash map to track visited nodes and their clones. Create new nodes and recursively clone neighbors.",
      "solution_code": "function cloneGraph(node) {\n    if (!node) return null;\n    \n    const cloned = new Map();\n    \n    function dfs(node) {\n        if (cloned.has(node)) {\n            return cloned.get(node);\n        }\n        \n        // Create clone\n        const clone = new Node(node.val, []);\n        cloned.set(node, clone);\n        \n        // Clone all neighbors\n        for (const neighbor of node.neighbors) {\n            clone.neighbors.push(dfs(neighbor));\n        }\n        \n        return clone;\n    }\n    \n    return dfs(node);\n}"
    },
    "typescript": {
      "template": "function cloneGraph(node: Node | null): Node | null {\n  \n}",
      "solution_text": "Use DFS with hash map to track visited nodes and their clones. Create new nodes and recursively clone neighbors.",
      "solution_code": "function cloneGraph(node: Node | null): Node | null {\n    if (!node) return null;\n    \n    const cloned = new Map<Node, Node>();\n    \n    function dfs(node: Node): Node {\n        if (cloned.has(node)) {\n            return cloned.get(node)!;\n        }\n        \n        // Create clone\n        const clone = new Node(node.val, []);\n        cloned.set(node, clone);\n        \n        // Clone all neighbors\n        for (const neighbor of node.neighbors) {\n            clone.neighbors.push(dfs(neighbor));\n        }\n        \n        return clone;\n    }\n    \n    return dfs(node);\n}"
    },
    "java": {
      "template": "class Solution {\n    public Node cloneGraph(Node node) {\n        \n    }\n}",
      "solution_text": "Use DFS with hash map to track visited nodes and their clones. Create new nodes and recursively clone neighbors.",
      "solution_code": "class Solution {\n    private Map<Node, Node> cloned = new HashMap<>();\n    \n    public Node cloneGraph(Node node) {\n        if (node == null) return null;\n        \n        if (cloned.containsKey(node)) {\n            return cloned.get(node);\n        }\n        \n        // Create clone\n        Node clone = new Node(node.val, new ArrayList<>());\n        cloned.put(node, clone);\n        \n        // Clone all neighbors\n        for (Node neighbor : node.neighbors) {\n            clone.neighbors.add(cloneGraph(neighbor));\n        }\n        \n        return clone;\n    }\n}"
    }
  },
  "order_matters": false,
  "test_cases": [
    {
      "id": 1,
      "input": {
        "adjList": [
          [
            2,
            4
          ],
          [
            1,
            3
          ],
          [
            2,
            4
          ],
          [
            1,
            3
          ]
        ]
      },
      "output": [
        [
          2,
          4
        ],
        [
          1,
          3
        ],
        [
          2,
          4
        ],
        [
          1,
          3
        ]
      ]
    },
    {
      "id": 2,
      "input": {
        "adjList": [
          []
        ]
      },
      "output": [
        []
      ]
    },
    {
      "id": 3,
      "input": {
        "adjList": []
      },
      "output": []
    }
  ]
}