{
  "filename": "climbing-stairs",
  "title": "Climbing Stairs",
  "keywords": [
    "climbing",
    "stairs",
    "leetcode",
    "given",
    "integer",
    "representing",
    "number",
    "steps",
    "reach",
    "top"
  ],
  "description": "<h2>Climbing Stairs</h2><p>Leetcode 70. Climbing Stairs</p><p></p><p>You are given an integer `n` representing the number of steps to reach the top of a staircase. You can climb with either `1` or `2` steps at a time.</p><p>    </p><p>Return the number of distinct ways to climb to the top of the staircase.</p><h3>Examples:</h3><ul><li>Input: n = 2<br><br>Output: 2<br>1. `1 + 1 = 2`\n2. `2 = 2`</li><li>Input: n = 3<br><br>Output: 3<br>1. `1 + 1 + 1 = 3`\n2. `1 + 2 = 3`\n3. `2 + 1 = 3`</li></ul><h3>Constraints:</h3><ul><li> `1 <= n <= 30`</li></ul>",
  "languages": {
    "python": {
      "template": "def climbingStairs(n):\n    ",
      "solution_text": "Dynamic Programming solution for Climbing Stairs:\n\n**Algorithm:**\n1. Base cases: 1 way to reach step 0 or 1\n2. For each step, ways = ways(n-1) + ways(n-2)\n3. Use space optimization with two variables\n\n**Time Complexity:** O(n) - linear iteration\n**Space Complexity:** O(1) - constant space with optimization\n\n**Key Insights:**\n- Similar to Fibonacci sequence\n- Bottom-up dynamic programming\n- Space can be optimized to O(1)",
      "solution_code": "def climbingStairs(n):\n    if n <= 1:\n        return 1\n    \n    # Space-optimized DP\n    prev2, prev1 = 1, 1\n    \n    for i in range(2, n + 1):\n        current = prev1 + prev2\n        prev2, prev1 = prev1, current\n    \n    return prev1"
    },
    "javascript": {
      "template": "function climbingStairs(n) {\n  \n}",
      "solution_text": "Dynamic Programming solution for Climbing Stairs:\n\n**Algorithm:**\n1. Base cases: 1 way to reach step 0 or 1\n2. For each step, ways = ways(n-1) + ways(n-2)\n3. Use space optimization with two variables\n\n**Time Complexity:** O(n) - linear iteration\n**Space Complexity:** O(1) - constant space with optimization\n\n**Key Insights:**\n- Similar to Fibonacci sequence\n- Bottom-up dynamic programming\n- Space can be optimized to O(1)",
      "solution_code": "function climbingStairs(n) {\n    if (n <= 1) return 1;\n    \n    // Space-optimized DP\n    let prev2 = 1, prev1 = 1;\n    \n    for (let i = 2; i <= n; i++) {\n        const current = prev1 + prev2;\n        prev2 = prev1;\n        prev1 = current;\n    }\n    \n    return prev1;\n}"
    },
    "typescript": {
      "template": "function climbingStairs(n: number): number {\n  \n}",
      "solution_text": "Dynamic Programming solution for Climbing Stairs:\n\n**Algorithm:**\n1. Base cases: 1 way to reach step 0 or 1\n2. For each step, ways = ways(n-1) + ways(n-2)\n3. Use space optimization with two variables\n\n**Time Complexity:** O(n) - linear iteration\n**Space Complexity:** O(1) - constant space with optimization\n\n**Key Insights:**\n- Similar to Fibonacci sequence\n- Bottom-up dynamic programming\n- Space can be optimized to O(1)",
      "solution_code": "function climbingStairs(n: number): number {\n    if (n <= 1) return 1;\n    \n    // Space-optimized DP\n    let prev2 = 1, prev1 = 1;\n    \n    for (let i = 2; i <= n; i++) {\n        const current = prev1 + prev2;\n        prev2 = prev1;\n        prev1 = current;\n    }\n    \n    return prev1;\n}"
    },
    "java": {
      "template": "class Solution {\n    public int climbingStairs(int n) {\n        \n    }\n}",
      "solution_text": "Dynamic Programming solution for Climbing Stairs:\n\n**Algorithm:**\n1. Base cases: 1 way to reach step 0 or 1\n2. For each step, ways = ways(n-1) + ways(n-2)\n3. Use space optimization with two variables\n\n**Time Complexity:** O(n) - linear iteration\n**Space Complexity:** O(1) - constant space with optimization\n\n**Key Insights:**\n- Similar to Fibonacci sequence\n- Bottom-up dynamic programming\n- Space can be optimized to O(1)",
      "solution_code": "class Solution {\n    public int climbingStairs(int n) {\n        if (n <= 1) return 1;\n        \n        // Space-optimized DP\n        int prev2 = 1, prev1 = 1;\n        \n        for (int i = 2; i <= n; i++) {\n            int current = prev1 + prev2;\n            prev2 = prev1;\n            prev1 = current;\n        }\n        \n        return prev1;\n    }\n}"
    }
  },
  "order_matters": false,
  "test_cases": [
    {
      "id": 1,
      "input": {
        "n": 2
      },
      "output": 2
    },
    {
      "id": 2,
      "input": {
        "n": 3
      },
      "output": 3
    }
  ]
}