{
  "filename": "add-two-numbers",
  "title": "Add Two Numbers",
  "keywords": [
    "add",
    "two",
    "numbers",
    "leetcode",
    "given",
    "non",
    "empty",
    "linked",
    "lists",
    "where"
  ],
  "description": "<h2>Add Two Numbers</h2><p>Leetcode 2. Add Two Numbers</p><p></p><p>You are given two **non-empty** linked lists, `l1` and `l2`, where each represents a non-negative integer.</p><p>    </p><p>The digits are stored in **reverse order**, e.g. the number 123 is represented as `3 -> 2 -> 1 ->` in the linked list.</p><p></p><p>Each of the nodes contains a single digit. You may assume the two numbers do not contain any leading zero, except the number 0 itself.</p><p></p><p>Return the sum of the two numbers as a linked list.</p><h3>Examples:</h3><ul><li>Input: l1 = [9], l2 = [9]<br><br>Output: [8,1]</li></ul><h3>Constraints:</h3><ul><li> `1 <= l1.length, l2.length <= 100`.</li><li> `0 <= Node.val <= 9`</li></ul>",
  "languages": {
    "python": {
      "template": "def addTwoNumbers(l1, l2):\n    ",
      "solution_text": "Add two numbers represented as linked lists in reverse order:\n\n**Algorithm:**\n1. Initialize dummy head and carry variable\n2. Traverse both linked lists simultaneously\n3. Add values with carry at each position\n4. Create new nodes for the result\n5. Handle remaining carry\n\n**Time Complexity:** O(max(m, n)) where m, n are lengths of input lists\n**Space Complexity:** O(max(m, n)) for the result list\n\n**Key Insights:**\n- Process digits from least to most significant (reverse order)\n- Handle carry propagation carefully\n- Create new linked list for result",
      "solution_code": "# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef addTwoNumbers(l1, l2):\n    dummy = ListNode(0)\n    current = dummy\n    carry = 0\n    \n    while l1 or l2 or carry:\n        val1 = l1.val if l1 else 0\n        val2 = l2.val if l2 else 0\n        \n        total = val1 + val2 + carry\n        carry = total // 10\n        digit = total % 10\n        \n        current.next = ListNode(digit)\n        current = current.next\n        \n        l1 = l1.next if l1 else None\n        l2 = l2.next if l2 else None\n    \n    return dummy.next"
    },
    "javascript": {
      "template": "function addTwoNumbers(l1, l2) {\n  \n}",
      "solution_text": "Add two numbers represented as linked lists in reverse order:\n\n**Algorithm:**\n1. Initialize dummy head and carry variable\n2. Traverse both linked lists simultaneously\n3. Add values with carry at each position\n4. Create new nodes for the result\n5. Handle remaining carry\n\n**Time Complexity:** O(max(m, n)) where m, n are lengths of input lists\n**Space Complexity:** O(max(m, n)) for the result list\n\n**Key Insights:**\n- Process digits from least to most significant (reverse order)\n- Handle carry propagation carefully\n- Create new linked list for result",
      "solution_code": "// Definition for singly-linked list.\nfunction ListNode(val, next) {\n    this.val = (val===undefined ? 0 : val);\n    this.next = (next===undefined ? null : next);\n}\n\nfunction addTwoNumbers(l1, l2) {\n    const dummy = new ListNode(0);\n    let current = dummy;\n    let carry = 0;\n    \n    while (l1 || l2 || carry) {\n        const val1 = l1 ? l1.val : 0;\n        const val2 = l2 ? l2.val : 0;\n        \n        const total = val1 + val2 + carry;\n        carry = Math.floor(total / 10);\n        const digit = total % 10;\n        \n        current.next = new ListNode(digit);\n        current = current.next;\n        \n        l1 = l1 ? l1.next : null;\n        l2 = l2 ? l2.next : null;\n    }\n    \n    return dummy.next;\n}"
    },
    "typescript": {
      "template": "function addTwoNumbers(l1: ListNode | null, l2: ListNode | null): ListNode | null {\n  \n}",
      "solution_text": "Add two numbers represented as linked lists in reverse order:\n\n**Algorithm:**\n1. Initialize dummy head and carry variable\n2. Traverse both linked lists simultaneously\n3. Add values with carry at each position\n4. Create new nodes for the result\n5. Handle remaining carry\n\n**Time Complexity:** O(max(m, n)) where m, n are lengths of input lists\n**Space Complexity:** O(max(m, n)) for the result list\n\n**Key Insights:**\n- Process digits from least to most significant (reverse order)\n- Handle carry propagation carefully\n- Create new linked list for result",
      "solution_code": "// Definition for singly-linked list.\nclass ListNode {\n    val: number;\n    next: ListNode | null;\n    constructor(val?: number, next?: ListNode | null) {\n        this.val = (val===undefined ? 0 : val);\n        this.next = (next===undefined ? null : next);\n    }\n}\n\nfunction addTwoNumbers(l1: ListNode | null, l2: ListNode | null): ListNode | null {\n    const dummy = new ListNode(0);\n    let current = dummy;\n    let carry = 0;\n    \n    while (l1 || l2 || carry) {\n        const val1 = l1 ? l1.val : 0;\n        const val2 = l2 ? l2.val : 0;\n        \n        const total = val1 + val2 + carry;\n        carry = Math.floor(total / 10);\n        const digit = total % 10;\n        \n        current.next = new ListNode(digit);\n        current = current.next;\n        \n        l1 = l1 ? l1.next : null;\n        l2 = l2 ? l2.next : null;\n    }\n    \n    return dummy.next;\n}"
    },
    "java": {
      "template": "class Solution {\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\n        \n    }\n}",
      "solution_text": "Add two numbers represented as linked lists in reverse order:\n\n**Algorithm:**\n1. Initialize dummy head and carry variable\n2. Traverse both linked lists simultaneously\n3. Add values with carry at each position\n4. Create new nodes for the result\n5. Handle remaining carry\n\n**Time Complexity:** O(max(m, n)) where m, n are lengths of input lists\n**Space Complexity:** O(max(m, n)) for the result list\n\n**Key Insights:**\n- Process digits from least to most significant (reverse order)\n- Handle carry propagation carefully\n- Create new linked list for result",
      "solution_code": "// Definition for singly-linked list.\nclass ListNode {\n    int val;\n    ListNode next;\n    ListNode() {}\n    ListNode(int val) { this.val = val; }\n    ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n}\n\nclass Solution {\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\n        ListNode dummy = new ListNode(0);\n        ListNode current = dummy;\n        int carry = 0;\n        \n        while (l1 != null || l2 != null || carry != 0) {\n            int val1 = (l1 != null) ? l1.val : 0;\n            int val2 = (l2 != null) ? l2.val : 0;\n            \n            int total = val1 + val2 + carry;\n            carry = total / 10;\n            int digit = total % 10;\n            \n            current.next = new ListNode(digit);\n            current = current.next;\n            \n            l1 = (l1 != null) ? l1.next : null;\n            l2 = (l2 != null) ? l2.next : null;\n        }\n        \n        return dummy.next;\n    }\n}"
    }
  },
  "order_matters": false,
  "test_cases": [
    {
      "id": 1,
      "input": {
        "l1": [
          9
        ],
        "l2": [
          9
        ]
      },
      "output": [
        8,
        1
      ]
    }
  ]
}