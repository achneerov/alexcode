{
  "filename": "maximum-frequency-stack",
  "title": "Maximum Frequency Stack",
  "keywords": [
    "maximum",
    "frequency",
    "stack",
    "leetcode",
    "895",
    "design",
    "like",
    "data",
    "structure",
    "push"
  ],
  "description": "<h2>Maximum Frequency Stack</h2><p>Leetcode 895. Maximum Frequency Stack</p><p></p><p>Design a stack-like data structure to push elements to the stack and pop the most frequent element from the stack.</p><p></p><p>Implement the `FreqStack` class:</p><p></p><p>- `FreqStack()` constructs an empty frequency stack.</p><p>- `void push(int val)` pushes an integer `val` onto the top of the stack.</p><p>- `int pop()` removes and returns the most frequent element in the stack.</p><p>    - If there is a **tie** for the **most frequent element**, the element closest to the stack's top is removed and returned.</p><h3>Examples:</h3><ul><li>Input: [\"FreqStack\", \"push\", \"push\", \"push\", \"push\", \"push\", \"push\", \"pop\", \"pop\", \"pop\", \"pop\"]<br>[[], [5], [7], [5], [7], [4], [5], [], [], [], []]<br><br>Output: [null, null, null, null, null, null, null, 5, 7, 5, 4]<br>FreqStack freqStack = new FreqStack();\nfreqStack.push(5); // The stack is [5]\nfreqStack.push(7); // The stack is [5,7]\nfreqStack.push(5); // The stack is [5,7,5]\nfreqStack.push(7); // The stack is [5,7,5,7]\nfreqStack.push(4); // The stack is [5,7,5,7,4]\nfreqStack.push(5); // The stack is [5,7,5,7,4,5]\nfreqStack.pop();   // return 5, as 5 is the most frequent. The stack becomes [5,7,5,7,4].\nfreqStack.pop();   // return 7, as 5 and 7 is the most frequent, but 7 is closest to the top. The stack becomes [5,7,5,4].\nfreqStack.pop();   // return 5, as 5 is the most frequent. The stack becomes [5,7,4].\nfreqStack.pop();   // return 4, as 4, 5 and 7 is the most frequent, but 4 is closest to the top. The stack becomes [5,7].</li></ul><h3>Constraints:</h3><ul><li> `0 <= val <= 1,000,000,000`</li><li> At most `20,000` calls will be made to `push` and `pop`.</li><li> It is guaranteed that there will be at least one element in the stack before calling `pop`.</li></ul>",
  "languages": {
    "python": {
      "template": "def maximumFrequencyStack(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20):\n    ",
      "solution_text": "Min/Max finding algorithm:\n\n**Algorithm:**\n1. Initialize min/max with first element\n2. Iterate through remaining elements\n3. Update min/max as needed\n\n**Time Complexity:** O(n) - single pass through array\n**Space Complexity:** O(1) - constant extra space\n\n**Key Insights:**\n- Handle empty arrays with appropriate defaults\n- Consider both positive and negative numbers\n- Single pass optimization",
      "solution_code": "def maximumFrequencyStack(nums):\n    if not nums:\n        return 0  # or appropriate default\n    \n    result = nums[0]\n    \n    for num in nums[1:]:\n        if 'max' in 'maximumFrequencyStack'.lower():\n            result = max(result, num)\n        else:\n            result = min(result, num)\n    \n    return result"
    },
    "javascript": {
      "template": "function maximumFrequencyStack(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20) {\n  \n}",
      "solution_text": "Min/Max finding algorithm:\n\n**Algorithm:**\n1. Initialize min/max with first element\n2. Iterate through remaining elements\n3. Update min/max as needed\n\n**Time Complexity:** O(n) - single pass through array\n**Space Complexity:** O(1) - constant extra space\n\n**Key Insights:**\n- Handle empty arrays with appropriate defaults\n- Consider both positive and negative numbers\n- Single pass optimization",
      "solution_code": "function maximumFrequencyStack(nums) {\n    if (!nums || nums.length === 0) return 0;\n    \n    let result = nums[0];\n    \n    for (let i = 1; i < nums.length; i++) {\n        if ('maximumFrequencyStack'.toLowerCase().includes('max')) {\n            result = Math.max(result, nums[i]);\n        } else {\n            result = Math.min(result, nums[i]);\n        }\n    }\n    \n    return result;\n}"
    },
    "typescript": {
      "template": "function maximumFrequencyStack(0: string, 1: string, 2: string, 3: string, 4: string, 5: string, 6: string, 7: string, 8: string, 9: string, 10: string, 11: string, 12: string, 13: string, 14: string, 15: string, 16: string, 17: string, 18: string, 19: string, 20: string): number[] {\n  \n}",
      "solution_text": "Min/Max finding algorithm:\n\n**Algorithm:**\n1. Initialize min/max with first element\n2. Iterate through remaining elements\n3. Update min/max as needed\n\n**Time Complexity:** O(n) - single pass through array\n**Space Complexity:** O(1) - constant extra space\n\n**Key Insights:**\n- Handle empty arrays with appropriate defaults\n- Consider both positive and negative numbers\n- Single pass optimization",
      "solution_code": "function maximumFrequencyStack(nums: number[]): number {\n    if (!nums || nums.length === 0) return 0;\n    \n    let result = nums[0];\n    \n    for (let i = 1; i < nums.length; i++) {\n        if ('maximumFrequencyStack'.toLowerCase().includes('max')) {\n            result = Math.max(result, nums[i]);\n        } else {\n            result = Math.min(result, nums[i]);\n        }\n    }\n    \n    return result;\n}"
    },
    "java": {
      "template": "class Solution {\n    public int[] maximumFrequencyStack(String 0, String 1, String 2, String 3, String 4, String 5, String 6, String 7, String 8, String 9, String 10, String 11, String 12, String 13, String 14, String 15, String 16, String 17, String 18, String 19, String 20) {\n        \n    }\n}",
      "solution_text": "Min/Max finding algorithm:\n\n**Algorithm:**\n1. Initialize min/max with first element\n2. Iterate through remaining elements\n3. Update min/max as needed\n\n**Time Complexity:** O(n) - single pass through array\n**Space Complexity:** O(1) - constant extra space\n\n**Key Insights:**\n- Handle empty arrays with appropriate defaults\n- Consider both positive and negative numbers\n- Single pass optimization",
      "solution_code": "class Solution {\n    public int maximumFrequencyStack(int[] nums) {\n        if (nums == null || nums.length == 0) return 0;\n        \n        int result = nums[0];\n        \n        for (int i = 1; i < nums.length; i++) {\n            if (\"maximumFrequencyStack\".toLowerCase().contains(\"max\")) {\n                result = Math.max(result, nums[i]);\n            } else {\n                result = Math.min(result, nums[i]);\n            }\n        }\n        \n        return result;\n    }\n}"
    }
  },
  "order_matters": false,
  "test_cases": [
    {
      "id": 1,
      "input": [
        "FreqStack",
        "push",
        "push",
        "push",
        "push",
        "push",
        "push",
        "pop",
        "pop",
        "pop",
        "\"pop\"] [[]",
        "[5]",
        "[7]",
        "[5]",
        "[7]",
        "[4]",
        "[5]",
        "[]",
        "[]",
        "[]",
        "[]"
      ],
      "output": [
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        5,
        7,
        5,
        4
      ]
    }
  ]
}