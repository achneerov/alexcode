{
  "filename": "merge-k-sorted-linked-lists",
  "title": "Merge K Sorted Linked Lists",
  "keywords": [
    "merge",
    "sorted",
    "linked",
    "lists",
    "leetcode",
    "given",
    "array",
    "where",
    "each",
    "list"
  ],
  "description": "<h2>Merge K Sorted Linked Lists</h2><p>Leetcode 23. Merge K Sorted Lists</p><p></p><p>You are given an array of `k` linked lists `lists`, where each list is sorted in ascending order.</p><p></p><p>Return the **sorted** linked list that is the result of merging all of the individual linked lists.</p><h3>Examples:</h3><ul><li>Input: lists = [[1,2,4],[1,3,5],[3,6]]<br><br>Output: [1,1,2,3,3,4,5,6]</li><li>Input: lists = []<br><br>Output: []</li><li>Input: lists = [[]]<br><br>Output: []</li></ul><h3>Constraints:</h3><ul><li> `0 <= lists.length <= 1000`</li><li> `0 <= lists[i].length <= 100`</li><li> `-1000 <= lists[i][j] <= 1000`</li></ul>",
  "languages": {
    "python": {
      "template": "def mergeKSortedLinkedLists(lists):\n    ",
      "solution_text": "Efficient sorting algorithm implementation:\n\n**Algorithm:**\n1. Choose appropriate sorting algorithm based on constraints\n2. For general case, use optimized comparison-based sort\n3. Handle edge cases like empty arrays\n4. Maintain stability if required\n\n**Time Complexity:** O(n log n) - optimal for comparison-based sorting\n**Space Complexity:** O(log n) - recursion stack for quicksort/mergesort\n\n**Key Insights:**\n- Built-in sorts are highly optimized\n- Consider counting sort for limited range integers\n- Stable sorts preserve relative order of equal elements",
      "solution_code": "def mergeKSortedLinkedLists(arr):\n    if not arr or len(arr) <= 1:\n        return arr\n    \n    # Use built-in optimized sort (Timsort)\n    return sorted(arr)\n    \n    # Alternative: in-place sorting\n    # arr.sort()\n    # return arr"
    },
    "javascript": {
      "template": "function mergeKSortedLinkedLists(lists) {\n  \n}",
      "solution_text": "Efficient sorting algorithm implementation:\n\n**Algorithm:**\n1. Choose appropriate sorting algorithm based on constraints\n2. For general case, use optimized comparison-based sort\n3. Handle edge cases like empty arrays\n4. Maintain stability if required\n\n**Time Complexity:** O(n log n) - optimal for comparison-based sorting\n**Space Complexity:** O(log n) - recursion stack for quicksort/mergesort\n\n**Key Insights:**\n- Built-in sorts are highly optimized\n- Consider counting sort for limited range integers\n- Stable sorts preserve relative order of equal elements",
      "solution_code": "function mergeKSortedLinkedLists(arr) {\n    if (!arr || arr.length <= 1) return arr;\n    \n    // Use built-in optimized sort\n    return [...arr].sort((a, b) => {\n        if (typeof a === 'number' && typeof b === 'number') {\n            return a - b;\n        }\n        return String(a).localeCompare(String(b));\n    });\n}"
    },
    "typescript": {
      "template": "function mergeKSortedLinkedLists(lists: number[]): number[] {\n  \n}",
      "solution_text": "Efficient sorting algorithm implementation:\n\n**Algorithm:**\n1. Choose appropriate sorting algorithm based on constraints\n2. For general case, use optimized comparison-based sort\n3. Handle edge cases like empty arrays\n4. Maintain stability if required\n\n**Time Complexity:** O(n log n) - optimal for comparison-based sorting\n**Space Complexity:** O(log n) - recursion stack for quicksort/mergesort\n\n**Key Insights:**\n- Built-in sorts are highly optimized\n- Consider counting sort for limited range integers\n- Stable sorts preserve relative order of equal elements",
      "solution_code": "function mergeKSortedLinkedLists(arr: any[]): any[] {\n    if (!arr || arr.length <= 1) return arr;\n    \n    // Use built-in optimized sort\n    return [...arr].sort((a, b) => {\n        if (typeof a === 'number' && typeof b === 'number') {\n            return a - b;\n        }\n        return String(a).localeCompare(String(b));\n    });\n}"
    },
    "java": {
      "template": "class Solution {\n    public int[] mergeKSortedLinkedLists(int[] lists) {\n        \n    }\n}",
      "solution_text": "Efficient sorting algorithm implementation:\n\n**Algorithm:**\n1. Choose appropriate sorting algorithm based on constraints\n2. For general case, use optimized comparison-based sort\n3. Handle edge cases like empty arrays\n4. Maintain stability if required\n\n**Time Complexity:** O(n log n) - optimal for comparison-based sorting\n**Space Complexity:** O(log n) - recursion stack for quicksort/mergesort\n\n**Key Insights:**\n- Built-in sorts are highly optimized\n- Consider counting sort for limited range integers\n- Stable sorts preserve relative order of equal elements",
      "solution_code": "class Solution {\n    public int[] mergeKSortedLinkedLists(int[] arr) {\n        if (arr == null || arr.length <= 1) return arr;\n        \n        // Create copy to avoid modifying original\n        int[] result = arr.clone();\n        \n        // Use built-in optimized sort (dual-pivot quicksort)\n        Arrays.sort(result);\n        \n        return result;\n    }\n}"
    }
  },
  "order_matters": false,
  "test_cases": [
    {
      "id": 1,
      "input": {
        "lists": [
          "[1",
          2,
          4
        ]
      },
      "output": [
        1,
        1,
        2,
        3,
        3,
        4,
        5,
        6
      ]
    },
    {
      "id": 2,
      "input": {
        "lists": []
      },
      "output": []
    },
    {
      "id": 3,
      "input": {
        "lists": [
          "["
        ]
      },
      "output": []
    }
  ]
}