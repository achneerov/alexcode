{
  "filename": "maximum-subarray",
  "title": "Maximum Subarray",
  "keywords": [
    "maximum",
    "subarray",
    "leetcode",
    "given",
    "array",
    "integers",
    "nums",
    "find",
    "largest",
    "sum"
  ],
  "description": "<h2>Maximum Subarray</h2><p>Leetcode 53. Maximum Subarray</p><p></p><p>Given an array of integers `nums`, find the subarray with the largest sum and return the sum.</p><p></p><p>A **subarray** is a contiguous non-empty sequence of elements within an array.</p><h3>Examples:</h3><ul><li>Input: nums = [2,-3,4,-2,2,1,-1,4]<br><br>Output: 8<br>The subarray [4,-2,2,1,-1,4] has the largest sum 8.</li><li>Input: nums = [-1]<br><br>Output: -1</li></ul><h3>Constraints:</h3><ul><li> `1 <= nums.length <= 1000`</li><li> `-1000 <= nums[i] <= 1000`</li></ul>",
  "languages": {
    "python": {
      "template": "def maximumSubarray(nums):\n    ",
      "solution_text": "Kadane's Algorithm for Maximum Subarray problem:\n\n**Algorithm:**\n1. Initialize max_sum to first element and current_sum to 0\n2. For each element, add it to current_sum\n3. Update max_sum if current_sum is greater\n4. If current_sum becomes negative, reset to 0\n\n**Time Complexity:** O(n) - single pass through array\n**Space Complexity:** O(1) - constant extra space\n\n**Key Insights:**\n- Dynamic programming approach\n- Negative prefixes are discarded\n- Handles all negative arrays correctly",
      "solution_code": "def maximumSubarray(nums):\n    if not nums:\n        return 0\n    \n    max_sum = nums[0]\n    current_sum = 0\n    \n    for num in nums:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n    \n    return max_sum"
    },
    "javascript": {
      "template": "function maximumSubarray(nums) {\n  \n}",
      "solution_text": "Kadane's Algorithm for Maximum Subarray problem:\n\n**Algorithm:**\n1. Initialize max_sum to first element and current_sum to 0\n2. For each element, add it to current_sum\n3. Update max_sum if current_sum is greater\n4. If current_sum becomes negative, reset to 0\n\n**Time Complexity:** O(n) - single pass through array\n**Space Complexity:** O(1) - constant extra space\n\n**Key Insights:**\n- Dynamic programming approach\n- Negative prefixes are discarded\n- Handles all negative arrays correctly",
      "solution_code": "function maximumSubarray(nums) {\n    if (!nums || nums.length === 0) return 0;\n    \n    let maxSum = nums[0];\n    let currentSum = 0;\n    \n    for (const num of nums) {\n        currentSum = Math.max(num, currentSum + num);\n        maxSum = Math.max(maxSum, currentSum);\n    }\n    \n    return maxSum;\n}"
    },
    "typescript": {
      "template": "function maximumSubarray(nums: number[]): number {\n  \n}",
      "solution_text": "Kadane's Algorithm for Maximum Subarray problem:\n\n**Algorithm:**\n1. Initialize max_sum to first element and current_sum to 0\n2. For each element, add it to current_sum\n3. Update max_sum if current_sum is greater\n4. If current_sum becomes negative, reset to 0\n\n**Time Complexity:** O(n) - single pass through array\n**Space Complexity:** O(1) - constant extra space\n\n**Key Insights:**\n- Dynamic programming approach\n- Negative prefixes are discarded\n- Handles all negative arrays correctly",
      "solution_code": "function maximumSubarray(nums: number[]): number {\n    if (!nums || nums.length === 0) return 0;\n    \n    let maxSum = nums[0];\n    let currentSum = 0;\n    \n    for (const num of nums) {\n        currentSum = Math.max(num, currentSum + num);\n        maxSum = Math.max(maxSum, currentSum);\n    }\n    \n    return maxSum;\n}"
    },
    "java": {
      "template": "class Solution {\n    public int maximumSubarray(int[] nums) {\n        \n    }\n}",
      "solution_text": "Kadane's Algorithm for Maximum Subarray problem:\n\n**Algorithm:**\n1. Initialize max_sum to first element and current_sum to 0\n2. For each element, add it to current_sum\n3. Update max_sum if current_sum is greater\n4. If current_sum becomes negative, reset to 0\n\n**Time Complexity:** O(n) - single pass through array\n**Space Complexity:** O(1) - constant extra space\n\n**Key Insights:**\n- Dynamic programming approach\n- Negative prefixes are discarded\n- Handles all negative arrays correctly",
      "solution_code": "class Solution {\n    public int maximumSubarray(int[] nums) {\n        if (nums == null || nums.length == 0) return 0;\n        \n        int maxSum = nums[0];\n        int currentSum = 0;\n        \n        for (int num : nums) {\n            currentSum = Math.max(num, currentSum + num);\n            maxSum = Math.max(maxSum, currentSum);\n        }\n        \n        return maxSum;\n    }\n}"
    }
  },
  "order_matters": false,
  "test_cases": [
    {
      "id": 1,
      "input": {
        "nums": [
          2,
          -3,
          4,
          -2,
          2,
          1,
          -1,
          4
        ]
      },
      "output": 8
    },
    {
      "id": 2,
      "input": {
        "nums": [
          -1
        ]
      },
      "output": -1
    }
  ]
}