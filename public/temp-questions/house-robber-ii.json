{
  "filename": "house-robber-ii",
  "title": "House Robber II",
  "keywords": [
    "house",
    "robber",
    "circular",
    "dynamic",
    "programming",
    "adjacent",
    "maximum"
  ],
  "description": "<h2>House Robber II</h2><p>You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. All houses at this place are <strong>arranged in a circle</strong>. That means the first house is the neighbor of the last one. Meanwhile, adjacent houses have security systems connected and <strong>it will automatically contact the police if two adjacent houses were broken into on the same night</strong>.</p><p>Given an integer array <code>nums</code> representing the amount of money of each house, return <em>the maximum amount of money you can rob tonight <strong>without alerting the police</strong></em>.</p><h3>Examples:</h3><ul><li><strong>Example 1:</strong><br>Input: nums = [2,3,2]<br>Output: 3<br>Explanation: You cannot rob house 1 (money = 2) and then rob house 3 (money = 2), because they are adjacent houses.</li><li><strong>Example 2:</strong><br>Input: nums = [1,2,3,1]<br>Output: 4<br>Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).<br>Total amount you can rob = 1 + 3 = 4.</li><li><strong>Example 3:</strong><br>Input: nums = [1,2,3]<br>Output: 3</li></ul><h3>Constraints:</h3><ul><li>1 <= nums.length <= 100</li><li>0 <= nums[i] <= 1000</li></ul>",
  "languages": {
    "python": {
      "template": "def rob(nums):\n    ",
      "solution_text": "Since houses are in a circle, we can't rob both first and last house. Solve two subproblems: rob houses 0 to n-2, and houses 1 to n-1.",
      "solution_code": "def rob(nums):\n    if len(nums) == 1:\n        return nums[0]\n    \n    def rob_linear(houses):\n        if not houses:\n            return 0\n        if len(houses) == 1:\n            return houses[0]\n        \n        prev2 = houses[0]\n        prev1 = max(houses[0], houses[1])\n        \n        for i in range(2, len(houses)):\n            current = max(prev1, prev2 + houses[i])\n            prev2 = prev1\n            prev1 = current\n        \n        return prev1\n    \n    # Case 1: Rob houses 0 to n-2 (exclude last)\n    # Case 2: Rob houses 1 to n-1 (exclude first)\n    return max(rob_linear(nums[:-1]), rob_linear(nums[1:]))"
    },
    "javascript": {
      "template": "function rob(nums) {\n  \n}",
      "solution_text": "Since houses are in a circle, we can't rob both first and last house. Solve two subproblems: rob houses 0 to n-2, and houses 1 to n-1.",
      "solution_code": "function rob(nums) {\n    if (nums.length === 1) return nums[0];\n    \n    function robLinear(houses) {\n        if (houses.length === 0) return 0;\n        if (houses.length === 1) return houses[0];\n        \n        let prev2 = houses[0];\n        let prev1 = Math.max(houses[0], houses[1]);\n        \n        for (let i = 2; i < houses.length; i++) {\n            const current = Math.max(prev1, prev2 + houses[i]);\n            prev2 = prev1;\n            prev1 = current;\n        }\n        \n        return prev1;\n    }\n    \n    // Case 1: Rob houses 0 to n-2 (exclude last)\n    // Case 2: Rob houses 1 to n-1 (exclude first)\n    return Math.max(robLinear(nums.slice(0, -1)), robLinear(nums.slice(1)));\n}"
    },
    "typescript": {
      "template": "function rob(nums: number[]): number {\n  \n}",
      "solution_text": "Since houses are in a circle, we can't rob both first and last house. Solve two subproblems: rob houses 0 to n-2, and houses 1 to n-1.",
      "solution_code": "function rob(nums: number[]): number {\n    if (nums.length === 1) return nums[0];\n    \n    function robLinear(houses: number[]): number {\n        if (houses.length === 0) return 0;\n        if (houses.length === 1) return houses[0];\n        \n        let prev2 = houses[0];\n        let prev1 = Math.max(houses[0], houses[1]);\n        \n        for (let i = 2; i < houses.length; i++) {\n            const current = Math.max(prev1, prev2 + houses[i]);\n            prev2 = prev1;\n            prev1 = current;\n        }\n        \n        return prev1;\n    }\n    \n    // Case 1: Rob houses 0 to n-2 (exclude last)\n    // Case 2: Rob houses 1 to n-1 (exclude first)\n    return Math.max(robLinear(nums.slice(0, -1)), robLinear(nums.slice(1)));\n}"
    },
    "java": {
      "template": "class Solution {\n    public int rob(int[] nums) {\n        \n    }\n}",
      "solution_text": "Since houses are in a circle, we can't rob both first and last house. Solve two subproblems: rob houses 0 to n-2, and houses 1 to n-1.",
      "solution_code": "class Solution {\n    public int rob(int[] nums) {\n        if (nums.length == 1) return nums[0];\n        \n        return Math.max(robLinear(Arrays.copyOfRange(nums, 0, nums.length - 1)),\n                       robLinear(Arrays.copyOfRange(nums, 1, nums.length)));\n    }\n    \n    private int robLinear(int[] houses) {\n        if (houses.length == 0) return 0;\n        if (houses.length == 1) return houses[0];\n        \n        int prev2 = houses[0];\n        int prev1 = Math.max(houses[0], houses[1]);\n        \n        for (int i = 2; i < houses.length; i++) {\n            int current = Math.max(prev1, prev2 + houses[i]);\n            prev2 = prev1;\n            prev1 = current;\n        }\n        \n        return prev1;\n    }\n}"
    }
  },
  "order_matters": false,
  "test_cases": [
    {
      "id": 1,
      "input": {
        "nums": [
          2,
          3,
          2
        ]
      },
      "output": 3
    },
    {
      "id": 2,
      "input": {
        "nums": [
          1,
          2,
          3,
          1
        ]
      },
      "output": 4
    },
    {
      "id": 3,
      "input": {
        "nums": [
          1,
          2,
          3
        ]
      },
      "output": 3
    }
  ]
}