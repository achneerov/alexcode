{
  "filename": "word-break-problem",
  "title": "Word Break",
  "keywords": [
    "word",
    "break",
    "dynamic",
    "programming",
    "dictionary",
    "segmentation"
  ],
  "description": "<h2>Word Break</h2><p>Given a string <code>s</code> and a dictionary of strings <code>wordDict</code>, return <code>true</code> if <code>s</code> can be segmented into a space-separated sequence of one or more dictionary words.</p><p><strong>Note</strong> that the same word in the dictionary may be reused multiple times in the segmentation.</p><h3>Examples:</h3><ul><li><strong>Example 1:</strong><br>Input: s = \"leetcode\", wordDict = [\"leet\",\"code\"]<br>Output: true<br>Explanation: Return true because \"leetcode\" can be segmented as \"leet code\".</li><li><strong>Example 2:</strong><br>Input: s = \"applepenapple\", wordDict = [\"apple\",\"pen\"]<br>Output: true<br>Explanation: Return true because \"applepenapple\" can be segmented as \"apple pen apple\".<br>Note that you are allowed to reuse a dictionary word.</li><li><strong>Example 3:</strong><br>Input: s = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]<br>Output: false</li></ul><h3>Constraints:</h3><ul><li>1 <= s.length <= 300</li><li>1 <= wordDict.length <= 1000</li><li>1 <= wordDict[i].length <= 20</li><li>s and wordDict[i] consist of only lowercase English letters.</li><li>All the strings of wordDict are unique.</li></ul>",
  "languages": {
    "python": {
      "template": "def wordBreak(s, wordDict):\n    ",
      "solution_text": "Use DP where dp[i] represents if s[0:i] can be segmented. For each position, check all possible words ending at that position.",
      "solution_code": "def wordBreak(s, wordDict):\n    word_set = set(wordDict)\n    dp = [False] * (len(s) + 1)\n    dp[0] = True\n    \n    for i in range(1, len(s) + 1):\n        for j in range(i):\n            if dp[j] and s[j:i] in word_set:\n                dp[i] = True\n                break\n    \n    return dp[len(s)]"
    },
    "javascript": {
      "template": "function wordBreak(s, wordDict) {\n  \n}",
      "solution_text": "Use DP where dp[i] represents if s[0:i] can be segmented. For each position, check all possible words ending at that position.",
      "solution_code": "function wordBreak(s, wordDict) {\n    const wordSet = new Set(wordDict);\n    const dp = new Array(s.length + 1).fill(false);\n    dp[0] = true;\n    \n    for (let i = 1; i <= s.length; i++) {\n        for (let j = 0; j < i; j++) {\n            if (dp[j] && wordSet.has(s.substring(j, i))) {\n                dp[i] = true;\n                break;\n            }\n        }\n    }\n    \n    return dp[s.length];\n}"
    },
    "typescript": {
      "template": "function wordBreak(s: string, wordDict: string[]): boolean {\n  \n}",
      "solution_text": "Use DP where dp[i] represents if s[0:i] can be segmented. For each position, check all possible words ending at that position.",
      "solution_code": "function wordBreak(s: string, wordDict: string[]): boolean {\n    const wordSet = new Set(wordDict);\n    const dp = new Array(s.length + 1).fill(false);\n    dp[0] = true;\n    \n    for (let i = 1; i <= s.length; i++) {\n        for (let j = 0; j < i; j++) {\n            if (dp[j] && wordSet.has(s.substring(j, i))) {\n                dp[i] = true;\n                break;\n            }\n        }\n    }\n    \n    return dp[s.length];\n}"
    },
    "java": {
      "template": "class Solution {\n    public boolean wordBreak(String s, List<String> wordDict) {\n        \n    }\n}",
      "solution_text": "Use DP where dp[i] represents if s[0:i] can be segmented. For each position, check all possible words ending at that position.",
      "solution_code": "class Solution {\n    public boolean wordBreak(String s, List<String> wordDict) {\n        Set<String> wordSet = new HashSet<>(wordDict);\n        boolean[] dp = new boolean[s.length() + 1];\n        dp[0] = true;\n        \n        for (int i = 1; i <= s.length(); i++) {\n            for (int j = 0; j < i; j++) {\n                if (dp[j] && wordSet.contains(s.substring(j, i))) {\n                    dp[i] = true;\n                    break;\n                }\n            }\n        }\n        \n        return dp[s.length()];\n    }\n}"
    }
  },
  "order_matters": false,
  "test_cases": [
    {
      "id": 1,
      "input": {
        "s": "leetcode",
        "wordDict": [
          "leet",
          "code"
        ]
      },
      "output": true
    },
    {
      "id": 2,
      "input": {
        "s": "applepenapple",
        "wordDict": [
          "apple",
          "pen"
        ]
      },
      "output": true
    },
    {
      "id": 3,
      "input": {
        "s": "catsandog",
        "wordDict": [
          "cats",
          "dog",
          "sand",
          "and",
          "cat"
        ]
      },
      "output": false
    }
  ]
}