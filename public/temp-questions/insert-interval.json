{
  "filename": "insert-interval",
  "title": "Insert Interval",
  "keywords": [
    "intervals",
    "insert",
    "merge",
    "overlapping",
    "array"
  ],
  "description": "<h2>Insert Interval</h2><p>You are given an array of non-overlapping intervals <code>intervals</code> where <code>intervals[i] = [starti, endi]</code> represent the start and the end of the <code>i<sup>th</sup></code> interval and <code>intervals</code> is sorted in ascending order by <code>starti</code>. You are also given an interval <code>newInterval = [start, end]</code> that represents the start and end of another interval.</p><p>Insert <code>newInterval</code> into <code>intervals</code> such that <code>intervals</code> is still sorted in ascending order by <code>starti</code> and <code>intervals</code> still does not have any overlapping intervals (merge overlapping intervals if necessary).</p><p>Return <code>intervals</code> <em>after the insertion</em>.</p><h3>Examples:</h3><ul><li><strong>Example 1:</strong><br>Input: intervals = [[1,3],[6,9]], newInterval = [2,5]<br>Output: [[1,5],[6,9]]</li><li><strong>Example 2:</strong><br>Input: intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]<br>Output: [[1,2],[3,10],[12,16]]</li></ul><h3>Constraints:</h3><ul><li>0 <= intervals.length <= 10^4</li><li>intervals[i].length == 2</li><li>0 <= starti <= endi <= 10^5</li><li>intervals is sorted by starti in ascending order.</li><li>newInterval.length == 2</li><li>0 <= start <= end <= 10^5</li></ul>",
  "languages": {
    "python": {
      "template": "def insert(intervals, newInterval):\n    ",
      "solution_text": "Insert the new interval while merging overlapping intervals. Process in three phases: before, overlap, and after.",
      "solution_code": "def insert(intervals, newInterval):\n    result = []\n    i = 0\n    n = len(intervals)\n    \n    # Add all intervals that end before newInterval starts\n    while i < n and intervals[i][1] < newInterval[0]:\n        result.append(intervals[i])\n        i += 1\n    \n    # Merge overlapping intervals with newInterval\n    while i < n and intervals[i][0] <= newInterval[1]:\n        newInterval[0] = min(newInterval[0], intervals[i][0])\n        newInterval[1] = max(newInterval[1], intervals[i][1])\n        i += 1\n    \n    result.append(newInterval)\n    \n    # Add remaining intervals\n    while i < n:\n        result.append(intervals[i])\n        i += 1\n    \n    return result"
    },
    "javascript": {
      "template": "function insert(intervals, newInterval) {\n  \n}",
      "solution_text": "Insert the new interval while merging overlapping intervals. Process in three phases: before, overlap, and after.",
      "solution_code": "function insert(intervals, newInterval) {\n    const result = [];\n    let i = 0;\n    \n    // Add all intervals that end before newInterval starts\n    while (i < intervals.length && intervals[i][1] < newInterval[0]) {\n        result.push(intervals[i]);\n        i++;\n    }\n    \n    // Merge overlapping intervals with newInterval\n    while (i < intervals.length && intervals[i][0] <= newInterval[1]) {\n        newInterval[0] = Math.min(newInterval[0], intervals[i][0]);\n        newInterval[1] = Math.max(newInterval[1], intervals[i][1]);\n        i++;\n    }\n    \n    result.push(newInterval);\n    \n    // Add remaining intervals\n    while (i < intervals.length) {\n        result.push(intervals[i]);\n        i++;\n    }\n    \n    return result;\n}"
    },
    "typescript": {
      "template": "function insert(intervals: number[][], newInterval: number[]): number[][] {\n  \n}",
      "solution_text": "Insert the new interval while merging overlapping intervals. Process in three phases: before, overlap, and after.",
      "solution_code": "function insert(intervals: number[][], newInterval: number[]): number[][] {\n    const result: number[][] = [];\n    let i = 0;\n    \n    // Add all intervals that end before newInterval starts\n    while (i < intervals.length && intervals[i][1] < newInterval[0]) {\n        result.push(intervals[i]);\n        i++;\n    }\n    \n    // Merge overlapping intervals with newInterval\n    while (i < intervals.length && intervals[i][0] <= newInterval[1]) {\n        newInterval[0] = Math.min(newInterval[0], intervals[i][0]);\n        newInterval[1] = Math.max(newInterval[1], intervals[i][1]);\n        i++;\n    }\n    \n    result.push(newInterval);\n    \n    // Add remaining intervals\n    while (i < intervals.length) {\n        result.push(intervals[i]);\n        i++;\n    }\n    \n    return result;\n}"
    },
    "java": {
      "template": "class Solution {\n    public int[][] insert(int[][] intervals, int[] newInterval) {\n        \n    }\n}",
      "solution_text": "Insert the new interval while merging overlapping intervals. Process in three phases: before, overlap, and after.",
      "solution_code": "class Solution {\n    public int[][] insert(int[][] intervals, int[] newInterval) {\n        List<int[]> result = new ArrayList<>();\n        int i = 0;\n        \n        // Add all intervals that end before newInterval starts\n        while (i < intervals.length && intervals[i][1] < newInterval[0]) {\n            result.add(intervals[i]);\n            i++;\n        }\n        \n        // Merge overlapping intervals with newInterval\n        while (i < intervals.length && intervals[i][0] <= newInterval[1]) {\n            newInterval[0] = Math.min(newInterval[0], intervals[i][0]);\n            newInterval[1] = Math.max(newInterval[1], intervals[i][1]);\n            i++;\n        }\n        \n        result.add(newInterval);\n        \n        // Add remaining intervals\n        while (i < intervals.length) {\n            result.add(intervals[i]);\n            i++;\n        }\n        \n        return result.toArray(new int[result.size()][]);\n    }\n}"
    }
  },
  "order_matters": false,
  "test_cases": [
    {
      "id": 1,
      "input": {
        "intervals": [
          [
            1,
            3
          ],
          [
            6,
            9
          ]
        ],
        "newInterval": [
          2,
          5
        ]
      },
      "output": [
        [
          1,
          5
        ],
        [
          6,
          9
        ]
      ]
    },
    {
      "id": 2,
      "input": {
        "intervals": [
          [
            1,
            2
          ],
          [
            3,
            5
          ],
          [
            6,
            7
          ],
          [
            8,
            10
          ],
          [
            12,
            16
          ]
        ],
        "newInterval": [
          4,
          8
        ]
      },
      "output": [
        [
          1,
          2
        ],
        [
          3,
          10
        ],
        [
          12,
          16
        ]
      ]
    },
    {
      "id": 3,
      "input": {
        "intervals": [],
        "newInterval": [
          5,
          7
        ]
      },
      "output": [
        [
          5,
          7
        ]
      ]
    }
  ]
}