{
  "filename": "encode-and-decode-strings",
  "title": "Encode and Decode Strings",
  "keywords": [
    "encode",
    "decode",
    "strings",
    "serialization",
    "delimiter",
    "length"
  ],
  "description": "<h2>Encode and Decode Strings</h2><p>Design an algorithm to encode a list of strings to a string. The encoded string is then sent over the network and is decoded back to the original list of strings.</p><p>Machine 1 (sender) has the function:</p><pre>string encode(vector&lt;string&gt; strs) {\n  // ... your code\n  return encoded_string;\n}</pre><p>Machine 2 (receiver) has the function:</p><pre>vector&lt;string&gt; decode(string s) {\n  // ... your code\n  return strs;\n}</pre><p>So Machine 1 does: <code>string encoded_string = encode(strs);</code></p><p>and Machine 2 does: <code>vector&lt;string&gt; strs2 = decode(encoded_string);</code></p><p><code>strs2</code> in Machine 2 should be the same as <code>strs</code> in Machine 1.</p><p>Implement the <code>encode</code> and <code>decode</code> methods.</p><p><strong>You are not allowed to solve the problem using any serialize methods (such as <code>eval</code>).</strong></p><h3>Examples:</h3><ul><li><strong>Example 1:</strong><br>Input: dummy_input = [\"Hello\",\"World\"]<br>Output: [\"Hello\",\"World\"]<br>Explanation:<br>Machine 1:<br>Codec encoder = new Codec();<br>String msg = encoder.encode(strs);<br>Machine 2:<br>Codec decoder = new Codec();<br>String[] strs = decoder.decode(msg);</li><li><strong>Example 2:</strong><br>Input: dummy_input = [\"\"]<br>Output: [\"\"]</li></ul><h3>Constraints:</h3><ul><li>1 <= strs.length <= 200</li><li>0 <= strs[i].length <= 200</li><li>strs[i] contains any possible characters out of 256 valid ASCII characters.</li></ul>",
  "languages": {
    "python": {
      "template": "def encode(strs):\n    \ndef decode(s):\n    ",
      "solution_text": "Use length-prefix encoding. Format: \"length:string\" for each string to handle any characters.",
      "solution_code": "def encode(strs):\n    encoded = \"\"\n    for s in strs:\n        encoded += str(len(s)) + \":\" + s\n    return encoded\n\ndef decode(s):\n    decoded = []\n    i = 0\n    while i < len(s):\n        # Find the delimiter\n        j = i\n        while s[j] != \":\":\n            j += 1\n        \n        # Extract length\n        length = int(s[i:j])\n        \n        # Extract string\n        decoded.append(s[j + 1:j + 1 + length])\n        \n        # Move to next string\n        i = j + 1 + length\n    \n    return decoded"
    },
    "javascript": {
      "template": "function encode(strs) {\n  \n}\n\nfunction decode(s) {\n  \n}",
      "solution_text": "Use length-prefix encoding. Format: \"length:string\" for each string to handle any characters.",
      "solution_code": "function encode(strs) {\n    let encoded = \"\";\n    for (const str of strs) {\n        encoded += str.length + \":\" + str;\n    }\n    return encoded;\n}\n\nfunction decode(s) {\n    const decoded = [];\n    let i = 0;\n    \n    while (i < s.length) {\n        // Find the delimiter\n        let j = i;\n        while (s[j] !== \":\") {\n            j++;\n        }\n        \n        // Extract length\n        const length = parseInt(s.substring(i, j));\n        \n        // Extract string\n        decoded.push(s.substring(j + 1, j + 1 + length));\n        \n        // Move to next string\n        i = j + 1 + length;\n    }\n    \n    return decoded;\n}"
    },
    "typescript": {
      "template": "function encode(strs: string[]): string {\n  \n}\n\nfunction decode(s: string): string[] {\n  \n}",
      "solution_text": "Use length-prefix encoding. Format: \"length:string\" for each string to handle any characters.",
      "solution_code": "function encode(strs: string[]): string {\n    let encoded = \"\";\n    for (const str of strs) {\n        encoded += str.length + \":\" + str;\n    }\n    return encoded;\n}\n\nfunction decode(s: string): string[] {\n    const decoded: string[] = [];\n    let i = 0;\n    \n    while (i < s.length) {\n        // Find the delimiter\n        let j = i;\n        while (s[j] !== \":\") {\n            j++;\n        }\n        \n        // Extract length\n        const length = parseInt(s.substring(i, j));\n        \n        // Extract string\n        decoded.push(s.substring(j + 1, j + 1 + length));\n        \n        // Move to next string\n        i = j + 1 + length;\n    }\n    \n    return decoded;\n}"
    },
    "java": {
      "template": "class Solution {\n    public String encode(List<String> strs) {\n        \n    }\n    \n    public List<String> decode(String s) {\n        \n    }\n}",
      "solution_text": "Use length-prefix encoding. Format: \"length:string\" for each string to handle any characters.",
      "solution_code": "class Solution {\n    public String encode(List<String> strs) {\n        StringBuilder encoded = new StringBuilder();\n        for (String str : strs) {\n            encoded.append(str.length()).append(\":\").append(str);\n        }\n        return encoded.toString();\n    }\n    \n    public List<String> decode(String s) {\n        List<String> decoded = new ArrayList<>();\n        int i = 0;\n        \n        while (i < s.length()) {\n            // Find the delimiter\n            int j = i;\n            while (s.charAt(j) != ':') {\n                j++;\n            }\n            \n            // Extract length\n            int length = Integer.parseInt(s.substring(i, j));\n            \n            // Extract string\n            decoded.add(s.substring(j + 1, j + 1 + length));\n            \n            // Move to next string\n            i = j + 1 + length;\n        }\n        \n        return decoded;\n    }\n}"
    }
  },
  "order_matters": false,
  "test_cases": [
    {
      "id": 1,
      "input": {
        "strs": [
          "Hello",
          "World"
        ]
      },
      "output": [
        "Hello",
        "World"
      ]
    },
    {
      "id": 2,
      "input": {
        "strs": [
          ""
        ]
      },
      "output": [
        ""
      ]
    }
  ]
}