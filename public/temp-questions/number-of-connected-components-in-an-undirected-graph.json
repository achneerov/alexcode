{
  "filename": "number-of-connected-components-in-an-undirected-graph",
  "title": "Number of Connected Components in an Undirected Graph",
  "keywords": [
    "graph",
    "connected",
    "components",
    "union",
    "find",
    "dfs"
  ],
  "description": "<h2>Number of Connected Components in an Undirected Graph</h2><p>You have a graph of <code>n</code> nodes. You are given an integer <code>n</code> and an array <code>edges</code> where <code>edges[i] = [ai, bi]</code> indicates that there is an edge between <code>ai</code> and <code>bi</code> in the graph.</p><p>Return <em>the number of connected components in the graph</em>.</p><h3>Examples:</h3><ul><li><strong>Example 1:</strong><br>Input: n = 5, edges = [[0,1],[1,2],[3,4]]<br>Output: 2</li><li><strong>Example 2:</strong><br>Input: n = 5, edges = [[0,1],[1,2],[2,3],[3,4]]<br>Output: 1</li></ul><h3>Constraints:</h3><ul><li>1 <= n <= 2000</li><li>1 <= edges.length <= 5000</li><li>edges[i].length == 2</li><li>0 <= ai <= bi < n</li><li>ai != bi</li><li>There are no repeated edges.</li></ul>",
  "languages": {
    "python": {
      "template": "def countComponents(n, edges):\n    ",
      "solution_text": "Use Union-Find (Disjoint Set Union) data structure to efficiently count connected components.",
      "solution_code": "def countComponents(n, edges):\n    parent = list(range(n))\n    \n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n    \n    def union(x, y):\n        px, py = find(x), find(y)\n        if px != py:\n            parent[px] = py\n    \n    for u, v in edges:\n        union(u, v)\n    \n    # Count unique roots\n    return len(set(find(i) for i in range(n)))"
    },
    "javascript": {
      "template": "function countComponents(n, edges) {\n  \n}",
      "solution_text": "Use Union-Find (Disjoint Set Union) data structure to efficiently count connected components.",
      "solution_code": "function countComponents(n, edges) {\n    const parent = Array.from({length: n}, (_, i) => i);\n    \n    function find(x) {\n        if (parent[x] !== x) {\n            parent[x] = find(parent[x]);\n        }\n        return parent[x];\n    }\n    \n    function union(x, y) {\n        const px = find(x);\n        const py = find(y);\n        if (px !== py) {\n            parent[px] = py;\n        }\n    }\n    \n    for (const [u, v] of edges) {\n        union(u, v);\n    }\n    \n    // Count unique roots\n    const roots = new Set();\n    for (let i = 0; i < n; i++) {\n        roots.add(find(i));\n    }\n    return roots.size;\n}"
    },
    "typescript": {
      "template": "function countComponents(n: number, edges: number[][]): number {\n  \n}",
      "solution_text": "Use Union-Find (Disjoint Set Union) data structure to efficiently count connected components.",
      "solution_code": "function countComponents(n: number, edges: number[][]): number {\n    const parent: number[] = Array.from({length: n}, (_, i) => i);\n    \n    function find(x: number): number {\n        if (parent[x] !== x) {\n            parent[x] = find(parent[x]);\n        }\n        return parent[x];\n    }\n    \n    function union(x: number, y: number): void {\n        const px = find(x);\n        const py = find(y);\n        if (px !== py) {\n            parent[px] = py;\n        }\n    }\n    \n    for (const [u, v] of edges) {\n        union(u, v);\n    }\n    \n    // Count unique roots\n    const roots = new Set<number>();\n    for (let i = 0; i < n; i++) {\n        roots.add(find(i));\n    }\n    return roots.size;\n}"
    },
    "java": {
      "template": "class Solution {\n    public int countComponents(int n, int[][] edges) {\n        \n    }\n}",
      "solution_text": "Use Union-Find (Disjoint Set Union) data structure to efficiently count connected components.",
      "solution_code": "class Solution {\n    public int countComponents(int n, int[][] edges) {\n        int[] parent = new int[n];\n        for (int i = 0; i < n; i++) {\n            parent[i] = i;\n        }\n        \n        for (int[] edge : edges) {\n            union(edge[0], edge[1], parent);\n        }\n        \n        Set<Integer> roots = new HashSet<>();\n        for (int i = 0; i < n; i++) {\n            roots.add(find(i, parent));\n        }\n        return roots.size();\n    }\n    \n    private int find(int x, int[] parent) {\n        if (parent[x] != x) {\n            parent[x] = find(parent[x], parent);\n        }\n        return parent[x];\n    }\n    \n    private void union(int x, int y, int[] parent) {\n        int px = find(x, parent);\n        int py = find(y, parent);\n        if (px != py) {\n            parent[px] = py;\n        }\n    }\n}"
    }
  },
  "order_matters": false,
  "test_cases": [
    {
      "id": 1,
      "input": {
        "n": 5,
        "edges": [
          [
            0,
            1
          ],
          [
            1,
            2
          ],
          [
            3,
            4
          ]
        ]
      },
      "output": 2
    },
    {
      "id": 2,
      "input": {
        "n": 5,
        "edges": [
          [
            0,
            1
          ],
          [
            1,
            2
          ],
          [
            2,
            3
          ],
          [
            3,
            4
          ]
        ]
      },
      "output": 1
    },
    {
      "id": 3,
      "input": {
        "n": 3,
        "edges": []
      },
      "output": 3
    }
  ]
}