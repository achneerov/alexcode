{
  "filename": "merge-intervals",
  "title": "Merge Intervals",
  "keywords": [
    "intervals",
    "merge",
    "overlapping",
    "sorting",
    "greedy"
  ],
  "description": "<h2>Merge Intervals</h2><p>Given an array of <code>intervals</code> where <code>intervals[i] = [starti, endi]</code>, merge all overlapping intervals, and return <em>an array of the non-overlapping intervals that cover all the intervals in the input</em>.</p><h3>Examples:</h3><ul><li><strong>Example 1:</strong><br>Input: intervals = [[1,3],[2,6],[8,10],[15,18]]<br>Output: [[1,6],[8,10],[15,18]]<br>Explanation: Since intervals [1,3] and [2,6] overlap, merge them into [1,6].</li><li><strong>Example 2:</strong><br>Input: intervals = [[1,4],[4,5]]<br>Output: [[1,5]]<br>Explanation: Intervals [1,4] and [4,5] are considered overlapping.</li></ul><h3>Constraints:</h3><ul><li>1 <= intervals.length <= 10^4</li><li>intervals[i].length == 2</li><li>0 <= starti <= endi <= 10^4</li></ul>",
  "languages": {
    "python": {
      "template": "def merge(intervals):\n    ",
      "solution_text": "Sort intervals by start time, then merge overlapping intervals by comparing end times.",
      "solution_code": "def merge(intervals):\n    if not intervals:\n        return []\n    \n    # Sort intervals by start time\n    intervals.sort(key=lambda x: x[0])\n    \n    merged = [intervals[0]]\n    \n    for current in intervals[1:]:\n        last = merged[-1]\n        \n        # If current interval overlaps with the last merged interval\n        if current[0] <= last[1]:\n            # Merge them by updating the end time\n            last[1] = max(last[1], current[1])\n        else:\n            # No overlap, add current interval\n            merged.append(current)\n    \n    return merged"
    },
    "javascript": {
      "template": "function merge(intervals) {\n  \n}",
      "solution_text": "Sort intervals by start time, then merge overlapping intervals by comparing end times.",
      "solution_code": "function merge(intervals) {\n    if (intervals.length === 0) return [];\n    \n    // Sort intervals by start time\n    intervals.sort((a, b) => a[0] - b[0]);\n    \n    const merged = [intervals[0]];\n    \n    for (let i = 1; i < intervals.length; i++) {\n        const current = intervals[i];\n        const last = merged[merged.length - 1];\n        \n        // If current interval overlaps with the last merged interval\n        if (current[0] <= last[1]) {\n            // Merge them by updating the end time\n            last[1] = Math.max(last[1], current[1]);\n        } else {\n            // No overlap, add current interval\n            merged.push(current);\n        }\n    }\n    \n    return merged;\n}"
    },
    "typescript": {
      "template": "function merge(intervals: number[][]): number[][] {\n  \n}",
      "solution_text": "Sort intervals by start time, then merge overlapping intervals by comparing end times.",
      "solution_code": "function merge(intervals: number[][]): number[][] {\n    if (intervals.length === 0) return [];\n    \n    // Sort intervals by start time\n    intervals.sort((a, b) => a[0] - b[0]);\n    \n    const merged: number[][] = [intervals[0]];\n    \n    for (let i = 1; i < intervals.length; i++) {\n        const current = intervals[i];\n        const last = merged[merged.length - 1];\n        \n        // If current interval overlaps with the last merged interval\n        if (current[0] <= last[1]) {\n            // Merge them by updating the end time\n            last[1] = Math.max(last[1], current[1]);\n        } else {\n            // No overlap, add current interval\n            merged.push(current);\n        }\n    }\n    \n    return merged;\n}"
    },
    "java": {
      "template": "class Solution {\n    public int[][] merge(int[][] intervals) {\n        \n    }\n}",
      "solution_text": "Sort intervals by start time, then merge overlapping intervals by comparing end times.",
      "solution_code": "class Solution {\n    public int[][] merge(int[][] intervals) {\n        if (intervals.length == 0) return new int[0][];\n        \n        // Sort intervals by start time\n        Arrays.sort(intervals, (a, b) -> a[0] - b[0]);\n        \n        List<int[]> merged = new ArrayList<>();\n        merged.add(intervals[0]);\n        \n        for (int i = 1; i < intervals.length; i++) {\n            int[] current = intervals[i];\n            int[] last = merged.get(merged.size() - 1);\n            \n            // If current interval overlaps with the last merged interval\n            if (current[0] <= last[1]) {\n                // Merge them by updating the end time\n                last[1] = Math.max(last[1], current[1]);\n            } else {\n                // No overlap, add current interval\n                merged.add(current);\n            }\n        }\n        \n        return merged.toArray(new int[merged.size()][]);\n    }\n}"
    }
  },
  "order_matters": false,
  "test_cases": [
    {
      "id": 1,
      "input": {
        "intervals": [
          [
            1,
            3
          ],
          [
            2,
            6
          ],
          [
            8,
            10
          ],
          [
            15,
            18
          ]
        ]
      },
      "output": [
        [
          1,
          6
        ],
        [
          8,
          10
        ],
        [
          15,
          18
        ]
      ]
    },
    {
      "id": 2,
      "input": {
        "intervals": [
          [
            1,
            4
          ],
          [
            4,
            5
          ]
        ]
      },
      "output": [
        [
          1,
          5
        ]
      ]
    },
    {
      "id": 3,
      "input": {
        "intervals": [
          [
            1,
            4
          ],
          [
            2,
            3
          ]
        ]
      },
      "output": [
        [
          1,
          4
        ]
      ]
    }
  ]
}