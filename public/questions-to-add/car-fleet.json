{
  "filename": "car-fleet",
  "title": "Car Fleet",
  "keywords": [
    "car",
    "fleet",
    "leetcode",
    "853",
    "there",
    "cars",
    "traveling",
    "same",
    "destination",
    "one"
  ],
  "description": "<h2>Car Fleet</h2><p>Leetcode 853. Car Fleet</p><p></p><p>There are `n` cars traveling to the same destination on a one-lane highway.</p><p></p><p>You are given two arrays of integers `position` and `speed`, both of length `n`. </p><p>* `position[i]` is the position of the `ith car` (in miles)</p><p>* `speed[i]` is the speed of the `ith` car (in miles per hour)</p><p></p><p>The **destination** is at position `target` miles.</p><p></p><p>A car can **not** pass another car ahead of it. It can only catch up to another car and then drive at the same speed as the car ahead of it.</p><p></p><p>A **car fleet** is a non-empty set of cars driving at the same position and same speed. A single car is also considered a car fleet.</p><p></p><p>If a car catches up to a car fleet the moment the fleet reaches the destination, then the car is considered to be part of the fleet.</p><p></p><p>Return the number of **different car fleets** that will arrive at the destination.</p><h3>Examples:</h3><ul><li>Input: target = 10, position = [1,4], speed = [3,2]<br><br>Output: 1<br>The cars starting at 1 (speed 3) and 4 (speed 2) become a fleet, meeting each other at 10, the destination.</li><li>Input: target = 10, position = [4,1,0,7], speed = [2,2,1,1]<br><br>Output: 3<br>The cars starting at 4 and 7 become a fleet at position 10. The cars starting at 1 and 0 never catch up to the car ahead of them. Thus, there are 3 car fleets that will arrive at the destination.</li></ul><h3>Constraints:</h3><ul><li> `n == position.length == speed.length`.</li><li> `1 <= n <= 1000`</li><li> `0 < target <= 1000`</li><li> `0 < speed[i] <= 100`</li><li> `0 <= position[i] < target`</li><li> All the values of `position` are **unique**.</li></ul>",
  "languages": {
    "python": {
      "template": "def carFleet(target, position, speed):\n    ",
      "solution_text": "<p><strong>Car Fleet Solution using Stack:</strong></p><p>Key insight: Cars starting closer to the target will reach first, unless caught up by faster cars from behind.</p><p><strong>Algorithm:</strong></p><ol><li>Pair each car's position with speed and sort by position (descending)</li><li>Calculate time to reach target for each car</li><li>Use stack to track fleet formation: if current car takes less time, it forms a fleet with the car ahead</li><li>Count remaining stacks as separate fleets</li></ol><p><strong>Time Complexity:</strong> O(n log n) - for sorting</p><p><strong>Space Complexity:</strong> O(n) - for car data and stack</p>",
      "solution_code": "def carFleet(target, position, speed):\n    if not position:\n        return 0\n    \n    # Pair position and speed, then sort by position (descending)\n    cars = sorted(zip(position, speed), reverse=True)\n    \n    stack = []\n    \n    for pos, spd in cars:\n        # Calculate time to reach target\n        time = (target - pos) / spd\n        \n        # If this car reaches destination faster than the car ahead,\n        # it will catch up and form a fleet\n        while stack and time <= stack[-1]:\n            stack.pop()\n        \n        stack.append(time)\n    \n    return len(stack)"
    },
    "javascript": {
      "template": "function carFleet(target, position, speed) {\n  \n}",
      "solution_text": "<p><strong>Car Fleet Solution using Stack:</strong></p><p>Key insight: Cars starting closer to the target will reach first, unless caught up by faster cars from behind.</p><p><strong>Algorithm:</strong></p><ol><li>Pair each car's position with speed and sort by position (descending)</li><li>Calculate time to reach target for each car</li><li>Use stack to track fleet formation: if current car takes less time, it forms a fleet with the car ahead</li><li>Count remaining stacks as separate fleets</li></ol><p><strong>Time Complexity:</strong> O(n log n) - for sorting</p><p><strong>Space Complexity:</strong> O(n) - for car data and stack</p>",
      "solution_code": "function carFleet(target, position, speed) {\n    if (position.length === 0) return 0;\n    \n    // Pair position and speed, then sort by position (descending)\n    const cars = position.map((pos, i) => [pos, speed[i]])\n                         .sort((a, b) => b[0] - a[0]);\n    \n    const stack = [];\n    \n    for (const [pos, spd] of cars) {\n        // Calculate time to reach target\n        const time = (target - pos) / spd;\n        \n        // If this car reaches destination faster than the car ahead,\n        // it will catch up and form a fleet\n        while (stack.length > 0 && time <= stack[stack.length - 1]) {\n            stack.pop();\n        }\n        \n        stack.push(time);\n    }\n    \n    return stack.length;\n}"
    },
    "typescript": {
      "template": "function carFleet(target: number, position: number[], speed: number[]): number {\n  \n}",
      "solution_text": "<p><strong>Car Fleet Solution using Stack:</strong></p><p>Key insight: Cars starting closer to the target will reach first, unless caught up by faster cars from behind.</p><p><strong>Algorithm:</strong></p><ol><li>Pair each car's position with speed and sort by position (descending)</li><li>Calculate time to reach target for each car</li><li>Use stack to track fleet formation: if current car takes less time, it forms a fleet with the car ahead</li><li>Count remaining stacks as separate fleets</li></ol><p><strong>Time Complexity:</strong> O(n log n) - for sorting</p><p><strong>Space Complexity:</strong> O(n) - for car data and stack</p>",
      "solution_code": "function carFleet(target: number, position: number[], speed: number[]): number {\n    if (position.length === 0) return 0;\n    \n    // Pair position and speed, then sort by position (descending)\n    const cars: [number, number][] = position.map((pos, i) => [pos, speed[i]])\n                                            .sort((a, b) => b[0] - a[0]);\n    \n    const stack: number[] = [];\n    \n    for (const [pos, spd] of cars) {\n        // Calculate time to reach target\n        const time: number = (target - pos) / spd;\n        \n        // If this car reaches destination faster than the car ahead,\n        // it will catch up and form a fleet\n        while (stack.length > 0 && time <= stack[stack.length - 1]) {\n            stack.pop();\n        }\n        \n        stack.push(time);\n    }\n    \n    return stack.length;\n}"
    },
    "java": {
      "template": "class Solution {\n    public int carFleet(int target, int[] position, int[] speed) {\n        \n    }\n}",
      "solution_text": "<p><strong>Car Fleet Solution using Stack:</strong></p><p>Key insight: Cars starting closer to the target will reach first, unless caught up by faster cars from behind.</p><p><strong>Algorithm:</strong></p><ol><li>Pair each car's position with speed and sort by position (descending)</li><li>Calculate time to reach target for each car</li><li>Use stack to track fleet formation: if current car takes less time, it forms a fleet with the car ahead</li><li>Count remaining stacks as separate fleets</li></ol><p><strong>Time Complexity:</strong> O(n log n) - for sorting</p><p><strong>Space Complexity:</strong> O(n) - for car data and stack</p>",
      "solution_code": "class Solution {\n    public int carFleet(int target, int[] position, int[] speed) {\n        if (position.length == 0) return 0;\n        \n        // Create array of cars with position and speed\n        int n = position.length;\n        Car[] cars = new Car[n];\n        for (int i = 0; i < n; i++) {\n            cars[i] = new Car(position[i], speed[i]);\n        }\n        \n        // Sort by position (descending)\n        Arrays.sort(cars, (a, b) -> Integer.compare(b.position, a.position));\n        \n        Stack<Double> stack = new Stack<>();\n        \n        for (Car car : cars) {\n            // Calculate time to reach target\n            double time = (double)(target - car.position) / car.speed;\n            \n            // If this car reaches destination faster than the car ahead,\n            // it will catch up and form a fleet\n            while (!stack.isEmpty() && time <= stack.peek()) {\n                stack.pop();\n            }\n            \n            stack.push(time);\n        }\n        \n        return stack.size();\n    }\n    \n    class Car {\n        int position;\n        int speed;\n        \n        Car(int position, int speed) {\n            this.position = position;\n            this.speed = speed;\n        }\n    }\n}"
    }
  },
  "order_matters": false,
  "test_cases": [
    {
      "id": 1,
      "input": {
        "target": 10,
        "position": [
          1,
          4
        ],
        "speed": [
          3,
          2
        ]
      },
      "output": 1
    },
    {
      "id": 2,
      "input": {
        "target": 10,
        "position": [
          4,
          1,
          0,
          7
        ],
        "speed": [
          2,
          2,
          1,
          1
        ]
      },
      "output": 3
    }
  ]
}