{
  "filename": "balanced-binary-tree",
  "title": "Balanced Binary Tree",
  "keywords": [
    "balanced",
    "binary",
    "tree",
    "leetcode",
    "110",
    "given",
    "return",
    "true",
    "height",
    "false"
  ],
  "description": "<h2>Balanced Binary Tree</h2><p>Leetcode 110. Balanced Binary Tree</p><p></p><p>Given a binary tree, return `true` if it is **height-balanced** and `false` otherwise.</p><p></p><p>A **height-balanced** binary tree is defined as a binary tree in which the left and right subtrees of every node differ in height by no more than 1.</p><h3>Examples:</h3><ul><li>Input: root = []<br><br>Output: true</li></ul><h3>Constraints:</h3><ul><li> The number of nodes in the tree is in the range `[0, 1000]`.</li><li> `-1000 <= Node.val <= 1000`</li></ul>",
  "languages": {
    "python": {
      "template": "def balancedBinaryTree(root):\n    ",
      "solution_text": "Check if binary tree is height-balanced:\n\n**Algorithm:**\n1. Use helper function to compute height and check balance\n2. For each node, check if left and right subtrees are balanced\n3. Check if height difference is at most 1\n4. Return -1 if unbalanced, otherwise return height\n\n**Time Complexity:** O(n) - visit each node once\n**Space Complexity:** O(h) - recursion stack depth\n\n**Key Insights:**\n- Combine height calculation with balance checking\n- Early termination when imbalance is detected\n- Bottom-up approach for efficiency",
      "solution_code": "# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef balancedBinaryTree(root):\n    def check_balance(node):\n        # Base case: empty tree is balanced with height 0\n        if not node:\n            return 0\n        \n        # Check left subtree\n        left_height = check_balance(node.left)\n        if left_height == -1:\n            return -1  # Left subtree is unbalanced\n        \n        # Check right subtree\n        right_height = check_balance(node.right)\n        if right_height == -1:\n            return -1  # Right subtree is unbalanced\n        \n        # Check balance condition\n        if abs(left_height - right_height) > 1:\n            return -1  # Current node is unbalanced\n        \n        # Return height of current subtree\n        return max(left_height, right_height) + 1\n    \n    return check_balance(root) != -1"
    },
    "javascript": {
      "template": "function balancedBinaryTree(root) {\n  \n}",
      "solution_text": "Check if binary tree is height-balanced:\n\n**Algorithm:**\n1. Use helper function to compute height and check balance\n2. For each node, check if left and right subtrees are balanced\n3. Check if height difference is at most 1\n4. Return -1 if unbalanced, otherwise return height\n\n**Time Complexity:** O(n) - visit each node once\n**Space Complexity:** O(h) - recursion stack depth\n\n**Key Insights:**\n- Combine height calculation with balance checking\n- Early termination when imbalance is detected\n- Bottom-up approach for efficiency",
      "solution_code": "// Definition for a binary tree node.\nfunction TreeNode(val, left, right) {\n    this.val = (val===undefined ? 0 : val);\n    this.left = (left===undefined ? null : left);\n    this.right = (right===undefined ? null : right);\n}\n\nfunction balancedBinaryTree(root) {\n    function checkBalance(node) {\n        // Base case: empty tree is balanced with height 0\n        if (!node) return 0;\n        \n        // Check left subtree\n        const leftHeight = checkBalance(node.left);\n        if (leftHeight === -1) return -1; // Left subtree is unbalanced\n        \n        // Check right subtree\n        const rightHeight = checkBalance(node.right);\n        if (rightHeight === -1) return -1; // Right subtree is unbalanced\n        \n        // Check balance condition\n        if (Math.abs(leftHeight - rightHeight) > 1) {\n            return -1; // Current node is unbalanced\n        }\n        \n        // Return height of current subtree\n        return Math.max(leftHeight, rightHeight) + 1;\n    }\n    \n    return checkBalance(root) !== -1;\n}"
    },
    "typescript": {
      "template": "function balancedBinaryTree(root: TreeNode | null): boolean {\n  \n}",
      "solution_text": "Check if binary tree is height-balanced:\n\n**Algorithm:**\n1. Use helper function to compute height and check balance\n2. For each node, check if left and right subtrees are balanced\n3. Check if height difference is at most 1\n4. Return -1 if unbalanced, otherwise return height\n\n**Time Complexity:** O(n) - visit each node once\n**Space Complexity:** O(h) - recursion stack depth\n\n**Key Insights:**\n- Combine height calculation with balance checking\n- Early termination when imbalance is detected\n- Bottom-up approach for efficiency",
      "solution_code": "// Definition for a binary tree node.\nclass TreeNode {\n    val: number;\n    left: TreeNode | null;\n    right: TreeNode | null;\n    constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n        this.val = (val===undefined ? 0 : val);\n        this.left = (left===undefined ? null : left);\n        this.right = (right===undefined ? null : right);\n    }\n}\n\nfunction balancedBinaryTree(root: TreeNode | null): boolean {\n    function checkBalance(node: TreeNode | null): number {\n        // Base case: empty tree is balanced with height 0\n        if (!node) return 0;\n        \n        // Check left subtree\n        const leftHeight = checkBalance(node.left);\n        if (leftHeight === -1) return -1; // Left subtree is unbalanced\n        \n        // Check right subtree\n        const rightHeight = checkBalance(node.right);\n        if (rightHeight === -1) return -1; // Right subtree is unbalanced\n        \n        // Check balance condition\n        if (Math.abs(leftHeight - rightHeight) > 1) {\n            return -1; // Current node is unbalanced\n        }\n        \n        // Return height of current subtree\n        return Math.max(leftHeight, rightHeight) + 1;\n    }\n    \n    return checkBalance(root) !== -1;\n}"
    },
    "java": {
      "template": "class Solution {\n    public boolean isBalanced(TreeNode root) {\n        \n    }\n}",
      "solution_text": "Check if binary tree is height-balanced:\n\n**Algorithm:**\n1. Use helper function to compute height and check balance\n2. For each node, check if left and right subtrees are balanced\n3. Check if height difference is at most 1\n4. Return -1 if unbalanced, otherwise return height\n\n**Time Complexity:** O(n) - visit each node once\n**Space Complexity:** O(h) - recursion stack depth\n\n**Key Insights:**\n- Combine height calculation with balance checking\n- Early termination when imbalance is detected\n- Bottom-up approach for efficiency",
      "solution_code": "// Definition for a binary tree node.\nclass TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    TreeNode() {}\n    TreeNode(int val) { this.val = val; }\n    TreeNode(int val, TreeNode left, TreeNode right) {\n        this.val = val;\n        this.left = left;\n        this.right = right;\n    }\n}\n\nclass Solution {\n    public boolean isBalanced(TreeNode root) {\n        return checkBalance(root) != -1;\n    }\n    \n    private int checkBalance(TreeNode node) {\n        // Base case: empty tree is balanced with height 0\n        if (node == null) return 0;\n        \n        // Check left subtree\n        int leftHeight = checkBalance(node.left);\n        if (leftHeight == -1) return -1; // Left subtree is unbalanced\n        \n        // Check right subtree\n        int rightHeight = checkBalance(node.right);\n        if (rightHeight == -1) return -1; // Right subtree is unbalanced\n        \n        // Check balance condition\n        if (Math.abs(leftHeight - rightHeight) > 1) {\n            return -1; // Current node is unbalanced\n        }\n        \n        // Return height of current subtree\n        return Math.max(leftHeight, rightHeight) + 1;\n    }\n}"
    }
  },
  "order_matters": false,
  "test_cases": [
    {
      "id": 1,
      "input": {
        "root": []
      },
      "output": true
    }
  ]
}