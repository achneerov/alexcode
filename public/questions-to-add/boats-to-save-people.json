{
  "filename": "boats-to-save-people",
  "title": "Boats to Save People",
  "keywords": [
    "boats",
    "save",
    "people",
    "leetcode",
    "881",
    "given",
    "integer",
    "array",
    "where",
    "weight"
  ],
  "description": "<h2>Boats to Save People</h2><p>Leetcode 881. Boats to Save People</p><p></p><p>You are given an integer array `people` where `people[i]` is the weight of the `ith` person, and an **infinite number of boats** where each boat can carry a maximum weight of `limit`. Each boat carries **at most** two people at the same time, provided the sum of the weight of those people is at most `limit`.</p><p></p><p>Return the **minimum** number of boats to carry every given person.</p><h3>Examples:</h3><ul><li>Input: people = [5,1,4,2], limit = 6<br><br>Output: 2<br>First boat `[5,1]`.\nSecond boat `[4,2]`.</li><li>Input: people = [1,3,2,3,2], limit = 3<br><br>Output: 4<br>First boat `[3]`.\nSecond boat `[3]`.\nThird boat `[1,2]`.\nFourth boat `[2]`.</li></ul><h3>Constraints:</h3><ul><li> `1 <= people.length <= 50,000`</li><li> `1 <= people[i] <= limit <= 30,000`</li></ul>",
  "languages": {
    "python": {
      "template": "def boatsToSavePeople(people, limit):\n    ",
      "solution_text": "<h3>Boats to Save People</h3><p><strong>Algorithm:</strong></p><ol><li>Sort the people array by weight</li><li>Use two pointers: lightest person (left) and heaviest person (right)</li><li>Try to pair the lightest with the heaviest in one boat</li><li>If they can't fit together, the heavier person goes alone</li><li>Move pointers accordingly and count boats</li></ol><p><strong>Time Complexity:</strong> O(n log n) - due to sorting</p><p><strong>Space Complexity:</strong> O(1) - only using two pointers</p><p><strong>Key Insights:</strong></p><ul><li>Greedy approach: always try to pair lightest with heaviest</li><li>If heaviest can't pair with lightest, it can't pair with anyone</li><li>Two pointers technique after sorting optimizes the pairing</li></ul>",
      "solution_code": "def boatsToSavePeople(people, limit):\n    people.sort()\n    left, right = 0, len(people) - 1\n    boats = 0\n    \n    while left <= right:\n        # If both lightest and heaviest can fit in one boat\n        if people[left] + people[right] <= limit:\n            left += 1  # Take the lightest person too\n        \n        # Always take the heaviest person (right pointer)\n        right -= 1\n        boats += 1\n    \n    return boats"
    },
    "javascript": {
      "template": "function boatsToSavePeople(people, limit) {\n  \n}",
      "solution_text": "<h3>Boats to Save People</h3><p><strong>Algorithm:</strong></p><ol><li>Sort the people array by weight</li><li>Use two pointers: lightest person (left) and heaviest person (right)</li><li>Try to pair the lightest with the heaviest in one boat</li><li>If they can't fit together, the heavier person goes alone</li><li>Move pointers accordingly and count boats</li></ol><p><strong>Time Complexity:</strong> O(n log n) - due to sorting</p><p><strong>Space Complexity:</strong> O(1) - only using two pointers</p><p><strong>Key Insights:</strong></p><ul><li>Greedy approach: always try to pair lightest with heaviest</li><li>If heaviest can't pair with lightest, it can't pair with anyone</li><li>Two pointers technique after sorting optimizes the pairing</li></ul>",
      "solution_code": "function boatsToSavePeople(people, limit) {\n    people.sort((a, b) => a - b);\n    let left = 0, right = people.length - 1;\n    let boats = 0;\n    \n    while (left <= right) {\n        // If both lightest and heaviest can fit in one boat\n        if (people[left] + people[right] <= limit) {\n            left++; // Take the lightest person too\n        }\n        \n        // Always take the heaviest person (right pointer)\n        right--;\n        boats++;\n    }\n    \n    return boats;\n}"
    },
    "typescript": {
      "template": "function boatsToSavePeople(people: number[], limit: number): number {\n  \n}",
      "solution_text": "<h3>Boats to Save People</h3><p><strong>Algorithm:</strong></p><ol><li>Sort the people array by weight</li><li>Use two pointers: lightest person (left) and heaviest person (right)</li><li>Try to pair the lightest with the heaviest in one boat</li><li>If they can't fit together, the heavier person goes alone</li><li>Move pointers accordingly and count boats</li></ol><p><strong>Time Complexity:</strong> O(n log n) - due to sorting</p><p><strong>Space Complexity:</strong> O(1) - only using two pointers</p><p><strong>Key Insights:</strong></p><ul><li>Greedy approach: always try to pair lightest with heaviest</li><li>If heaviest can't pair with lightest, it can't pair with anyone</li><li>Two pointers technique after sorting optimizes the pairing</li></ul>",
      "solution_code": "function boatsToSavePeople(people: number[], limit: number): number {\n    people.sort((a, b) => a - b);\n    let left = 0, right = people.length - 1;\n    let boats = 0;\n    \n    while (left <= right) {\n        // If both lightest and heaviest can fit in one boat\n        if (people[left] + people[right] <= limit) {\n            left++; // Take the lightest person too\n        }\n        \n        // Always take the heaviest person (right pointer)\n        right--;\n        boats++;\n    }\n    \n    return boats;\n}"
    },
    "java": {
      "template": "class Solution {\n    public int boatsToSavePeople(int[] people, int limit) {\n        \n    }\n}",
      "solution_text": "<h3>Boats to Save People</h3><p><strong>Algorithm:</strong></p><ol><li>Sort the people array by weight</li><li>Use two pointers: lightest person (left) and heaviest person (right)</li><li>Try to pair the lightest with the heaviest in one boat</li><li>If they can't fit together, the heavier person goes alone</li><li>Move pointers accordingly and count boats</li></ol><p><strong>Time Complexity:</strong> O(n log n) - due to sorting</p><p><strong>Space Complexity:</strong> O(1) - only using two pointers</p><p><strong>Key Insights:</strong></p><ul><li>Greedy approach: always try to pair lightest with heaviest</li><li>If heaviest can't pair with lightest, it can't pair with anyone</li><li>Two pointers technique after sorting optimizes the pairing</li></ul>",
      "solution_code": "class Solution {\n    public int boatsToSavePeople(int[] people, int limit) {\n        Arrays.sort(people);\n        int left = 0, right = people.length - 1;\n        int boats = 0;\n        \n        while (left <= right) {\n            // If both lightest and heaviest can fit in one boat\n            if (people[left] + people[right] <= limit) {\n                left++; // Take the lightest person too\n            }\n            \n            // Always take the heaviest person (right pointer)\n            right--;\n            boats++;\n        }\n        \n        return boats;\n    }\n}"
    }
  },
  "order_matters": false,
  "test_cases": [
    {
      "id": 1,
      "input": {
        "people": [
          5,
          1,
          4,
          2
        ],
        "limit": 6
      },
      "output": 2
    },
    {
      "id": 2,
      "input": {
        "people": [
          1,
          3,
          2,
          3,
          2
        ],
        "limit": 3
      },
      "output": 4
    }
  ]
}