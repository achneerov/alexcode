{
  "filename": "combination-sum-iv",
  "title": "Combination Sum IV",
  "keywords": [
    "combination",
    "sum",
    "leetcode",
    "377",
    "given",
    "array",
    "distinct",
    "integers",
    "nums",
    "target"
  ],
  "description": "<h2>Combination Sum IV</h2><p>Leetcode 377. Combination Sum IV</p><p></p><p>You are given an array of **distinct** integers `nums` and a target integer `target`, return the number of possible combinations that add up to `target`.</p><p></p><p>The test cases are generated so that the answer can fit in a 32-bit integer.</p><h3>Examples:</h3><ul><li>Input: nums = [3,1,2], target = 4<br><br>Output: 7<br>The possible combination ways are:\n(1, 1, 1, 1)\n(1, 1, 2)\n(1, 2, 1)\n(1, 3)\n(2, 1, 1)\n(2, 2)\n(3, 1)</li><li>Input: nums = [1], target = 3<br><br>Output: 1</li></ul><h3>Constraints:</h3><ul><li> `1 <= nums.length <= 200`</li><li> `1 <= nums[i], target <= 1000`</li><li> All the elements of `nums` are **unique**.</li></ul>",
  "languages": {
    "python": {
      "template": "def combinationSumIv(nums, target):\n    ",
      "solution_text": "<p><strong>Dynamic Programming Solution for Combination Sum IV:</strong></p><p>Count combinations that sum to target (order matters).</p><p><strong>Algorithm:</strong></p><ol><li>Create DP array where dp[i] = number of ways to make sum i</li><li>Initialize dp[0] = 1 (one way to make sum 0: use no numbers)</li><li>For each target sum from 1 to target:</li><li>For each number in nums: if num <= current sum, add dp[sum - num] to dp[sum]</li></ol><p><strong>Key Insight:</strong> Order matters, so we iterate through target sums first, then numbers</p><p><strong>Time Complexity:</strong> O(target × n) where n is length of nums</p><p><strong>Space Complexity:</strong> O(target) for DP array</p>",
      "solution_code": "def combinationSumIv(nums, target):\n    # DP array: dp[i] = number of ways to make sum i\n    dp = [0] * (target + 1)\n    dp[0] = 1  # One way to make sum 0: use no numbers\n    \n    # For each target sum from 1 to target\n    for curr_sum in range(1, target + 1):\n        # Try each number in nums\n        for num in nums:\n            if num <= curr_sum:\n                dp[curr_sum] += dp[curr_sum - num]\n    \n    return dp[target]"
    },
    "javascript": {
      "template": "function combinationSumIv(nums, target) {\n  \n}",
      "solution_text": "<p><strong>Dynamic Programming Solution for Combination Sum IV:</strong></p><p>Count combinations that sum to target (order matters).</p><p><strong>Algorithm:</strong></p><ol><li>Create DP array where dp[i] = number of ways to make sum i</li><li>Initialize dp[0] = 1 (one way to make sum 0: use no numbers)</li><li>For each target sum from 1 to target:</li><li>For each number in nums: if num <= current sum, add dp[sum - num] to dp[sum]</li></ol><p><strong>Key Insight:</strong> Order matters, so we iterate through target sums first, then numbers</p><p><strong>Time Complexity:</strong> O(target × n) where n is length of nums</p><p><strong>Space Complexity:</strong> O(target) for DP array</p>",
      "solution_code": "function combinationSumIv(nums, target) {\n    // DP array: dp[i] = number of ways to make sum i\n    const dp = new Array(target + 1).fill(0);\n    dp[0] = 1;  // One way to make sum 0: use no numbers\n    \n    // For each target sum from 1 to target\n    for (let currSum = 1; currSum <= target; currSum++) {\n        // Try each number in nums\n        for (const num of nums) {\n            if (num <= currSum) {\n                dp[currSum] += dp[currSum - num];\n            }\n        }\n    }\n    \n    return dp[target];\n}"
    },
    "typescript": {
      "template": "function combinationSumIv(nums: number[], target: number): number {\n  \n}",
      "solution_text": "<p><strong>Dynamic Programming Solution for Combination Sum IV:</strong></p><p>Count combinations that sum to target (order matters).</p><p><strong>Algorithm:</strong></p><ol><li>Create DP array where dp[i] = number of ways to make sum i</li><li>Initialize dp[0] = 1 (one way to make sum 0: use no numbers)</li><li>For each target sum from 1 to target:</li><li>For each number in nums: if num <= current sum, add dp[sum - num] to dp[sum]</li></ol><p><strong>Key Insight:</strong> Order matters, so we iterate through target sums first, then numbers</p><p><strong>Time Complexity:</strong> O(target × n) where n is length of nums</p><p><strong>Space Complexity:</strong> O(target) for DP array</p>",
      "solution_code": "function combinationSumIv(nums: number[], target: number): number {\n    // DP array: dp[i] = number of ways to make sum i\n    const dp: number[] = new Array(target + 1).fill(0);\n    dp[0] = 1;  // One way to make sum 0: use no numbers\n    \n    // For each target sum from 1 to target\n    for (let currSum = 1; currSum <= target; currSum++) {\n        // Try each number in nums\n        for (const num of nums) {\n            if (num <= currSum) {\n                dp[currSum] += dp[currSum - num];\n            }\n        }\n    }\n    \n    return dp[target];\n}"
    },
    "java": {
      "template": "class Solution {\n    public int combinationSumIv(int[] nums, int target) {\n        \n    }\n}",
      "solution_text": "<p><strong>Dynamic Programming Solution for Combination Sum IV:</strong></p><p>Count combinations that sum to target (order matters).</p><p><strong>Algorithm:</strong></p><ol><li>Create DP array where dp[i] = number of ways to make sum i</li><li>Initialize dp[0] = 1 (one way to make sum 0: use no numbers)</li><li>For each target sum from 1 to target:</li><li>For each number in nums: if num <= current sum, add dp[sum - num] to dp[sum]</li></ol><p><strong>Key Insight:</strong> Order matters, so we iterate through target sums first, then numbers</p><p><strong>Time Complexity:</strong> O(target × n) where n is length of nums</p><p><strong>Space Complexity:</strong> O(target) for DP array</p>",
      "solution_code": "class Solution {\n    public int combinationSumIv(int[] nums, int target) {\n        // DP array: dp[i] = number of ways to make sum i\n        int[] dp = new int[target + 1];\n        dp[0] = 1;  // One way to make sum 0: use no numbers\n        \n        // For each target sum from 1 to target\n        for (int currSum = 1; currSum <= target; currSum++) {\n            // Try each number in nums\n            for (int num : nums) {\n                if (num <= currSum) {\n                    dp[currSum] += dp[currSum - num];\n                }\n            }\n        }\n        \n        return dp[target];\n    }\n}"
    }
  },
  "order_matters": false,
  "test_cases": [
    {
      "id": 1,
      "input": {
        "nums": [
          3,
          1,
          2
        ],
        "target": 4
      },
      "output": 7
    },
    {
      "id": 2,
      "input": {
        "nums": [
          1
        ],
        "target": 3
      },
      "output": 1
    }
  ]
}