{
  "filename": "max-water-container",
  "title": "Container With Most Water",
  "keywords": [
    "container",
    "most",
    "water",
    "leetcode",
    "given",
    "integer",
    "array",
    "heights",
    "where",
    "represents"
  ],
  "description": "<h2>Container With Most Water</h2><p>Leetcode 11. Container With Most Water</p><p></p><p>You are given an integer array `heights` where `heights[i]` represents the height of the $i^{th}$ bar.</p><p></p><p>You may choose any two bars to form a container. Return the *maximum* amount of water a container can store.</p><h3>Examples:</h3><ul><li>Input: height = [2,2,2]<br><br>Output: 4</li></ul><h3>Constraints:</h3><ul><li> `2 <= height.length <= 1000`</li><li> `0 <= height[i] <= 1000`</li></ul>",
  "languages": {
    "python": {
      "template": "def containerWithMostWater(height):\n    ",
      "solution_text": "Container with Most Water using Two Pointers:\n\n**Algorithm:**\n1. Use two pointers at start and end of array\n2. Calculate area with current pointers\n3. Move pointer with smaller height inward\n4. Keep track of maximum area seen\n\n**Time Complexity:** O(n) - Single pass through array\n**Space Complexity:** O(1) - Only using two pointers\n\n**Key Insights:**\n- Moving the shorter line gives potential for larger area\n- Two pointers converge to optimal solution\n- Area = width × min(height[left], height[right])",
      "solution_code": "def containerWithMostWater(height):\n    left, right = 0, len(height) - 1\n    max_area = 0\n    \n    while left < right:\n        # Calculate area with current pointers\n        width = right - left\n        area = width * min(height[left], height[right])\n        max_area = max(max_area, area)\n        \n        # Move pointer with smaller height\n        if height[left] < height[right]:\n            left += 1\n        else:\n            right -= 1\n    \n    return max_area"
    },
    "javascript": {
      "template": "function containerWithMostWater(height) {\n  \n}",
      "solution_text": "Container with Most Water using Two Pointers:\n\n**Algorithm:**\n1. Use two pointers at start and end of array\n2. Calculate area with current pointers\n3. Move pointer with smaller height inward\n4. Keep track of maximum area seen\n\n**Time Complexity:** O(n) - Single pass through array\n**Space Complexity:** O(1) - Only using two pointers\n\n**Key Insights:**\n- Moving the shorter line gives potential for larger area\n- Two pointers converge to optimal solution\n- Area = width × min(height[left], height[right])",
      "solution_code": "function containerWithMostWater(height) {\n    let left = 0, right = height.length - 1;\n    let maxArea = 0;\n    \n    while (left < right) {\n        // Calculate area with current pointers\n        const width = right - left;\n        const area = width * Math.min(height[left], height[right]);\n        maxArea = Math.max(maxArea, area);\n        \n        // Move pointer with smaller height\n        if (height[left] < height[right]) {\n            left++;\n        } else {\n            right--;\n        }\n    }\n    \n    return maxArea;\n}"
    },
    "typescript": {
      "template": "function containerWithMostWater(height: number[]): number {\n  \n}",
      "solution_text": "Container with Most Water using Two Pointers:\n\n**Algorithm:**\n1. Use two pointers at start and end of array\n2. Calculate area with current pointers\n3. Move pointer with smaller height inward\n4. Keep track of maximum area seen\n\n**Time Complexity:** O(n) - Single pass through array\n**Space Complexity:** O(1) - Only using two pointers\n\n**Key Insights:**\n- Moving the shorter line gives potential for larger area\n- Two pointers converge to optimal solution\n- Area = width × min(height[left], height[right])",
      "solution_code": "function containerWithMostWater(height: number[]): number {\n    let left = 0, right = height.length - 1;\n    let maxArea = 0;\n    \n    while (left < right) {\n        // Calculate area with current pointers\n        const width = right - left;\n        const area = width * Math.min(height[left], height[right]);\n        maxArea = Math.max(maxArea, area);\n        \n        // Move pointer with smaller height\n        if (height[left] < height[right]) {\n            left++;\n        } else {\n            right--;\n        }\n    }\n    \n    return maxArea;\n}"
    },
    "java": {
      "template": "class Solution {\n    public int containerWithMostWater(int[] height) {\n        \n    }\n}",
      "solution_text": "Container with Most Water using Two Pointers:\n\n**Algorithm:**\n1. Use two pointers at start and end of array\n2. Calculate area with current pointers\n3. Move pointer with smaller height inward\n4. Keep track of maximum area seen\n\n**Time Complexity:** O(n) - Single pass through array\n**Space Complexity:** O(1) - Only using two pointers\n\n**Key Insights:**\n- Moving the shorter line gives potential for larger area\n- Two pointers converge to optimal solution\n- Area = width × min(height[left], height[right])",
      "solution_code": "class Solution {\n    public int containerWithMostWater(int[] height) {\n        int left = 0, right = height.length - 1;\n        int maxArea = 0;\n        \n        while (left < right) {\n            // Calculate area with current pointers\n            int width = right - left;\n            int area = width * Math.min(height[left], height[right]);\n            maxArea = Math.max(maxArea, area);\n            \n            // Move pointer with smaller height\n            if (height[left] < height[right]) {\n                left++;\n            } else {\n                right--;\n            }\n        }\n        \n        return maxArea;\n    }\n}"
    }
  },
  "order_matters": false,
  "test_cases": [
    {
      "id": 1,
      "input": {
        "height": [
          2,
          2,
          2
        ]
      },
      "output": 4
    }
  ]
}