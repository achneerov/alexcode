{
  "filename": "baseball-game",
  "title": "Baseball Game",
  "keywords": [
    "baseball",
    "game",
    "leetcode",
    "682",
    "keeping",
    "scores",
    "strange",
    "rules",
    "beginning",
    "start"
  ],
  "description": "<h2>Baseball Game</h2><p>Leetcode 682. Baseball Game</p><p></p><p>You are keeping the scores for a baseball game with strange rules. At the beginning of the game, you start with an empty record.</p><p></p><p>Given a list of strings `operations`, where `operations[i]` is the `ith` operation you must apply to the record and is one of the following:</p><p></p><p>- An integer `x`: Record a new score of `x`.</p><p></p><p>- '+': Record a new score that is the sum of the previous two scores.</p><p></p><p>- 'D': Record a new score that is the double of the previous score.</p><p></p><p>- 'C': Invalidate the previous score, removing it from the record.</p><p></p><p>Return the sum of all the scores on the record after applying all the operations.</p><p></p><p>Note: The test cases are generated such that the answer and all intermediate calculations fit in a `32`-bit integer and that all operations are valid.</p><h3>Examples:</h3><ul><li>Input: ops = [\"1\",\"2\",\"+\",\"C\",\"5\",\"D\"]<br><br>Output: 18<br>- `\"1\"` - Add 1 to the record, record = [1].\n- `\"2\"` - Add 2 to the record, record = [1, 2].\n- `\"+\"` - Add `1 + 2 = 3` to the record, record = [1, 2, 3].\n- `\"C\"` - Invalidate and remove the previous score, record = [1, 2].\n- `\"5\"` - Add 5 to the record, record = [1, 2, 5].\n- `\"D\"` - Add `2 * 5 = 10` to the record, record = [1, 2, 5, 10].\n- The total sum is `1 + 2 + 5 + 10 = 18`.</li><li>Input: ops = [\"5\",\"D\",\"+\",\"C\"]<br><br>Output: 15<br>- `\"5\"` - Add 5 to the record, record = [5].\n- `\"D\"` - Add `2 * 5 = 10` to the record, record = [5, 10].\n- `\"+\"` - Add `5 + 10 = 15` to the record, record = [5, 10, 15].\n- `\"C\"` - Invalidate and remove the previous score, record = [5, 10].\n- The total sum is `5 + 10 = 15`.</li></ul><h3>Constraints:</h3><ul><li> `1 <= operations.length <= 1000`</li><li> `operations[i]` is `\"C\"`, `\"D\"`, `+`, or a string representing an integer in the range `[(-30,000), (30,000)]`.</li><li> For operation `\"+\"`, there will always be at least two previous scores on the record.</li><li> For operations `\"C\"` and `\"D\"`, there will always be at least one previous score on the record.</li></ul>",
  "languages": {
    "python": {
      "template": "def baseballGame(ops):\n    ",
      "solution_text": "Baseball game scoring with stack operations:\n\n**Algorithm:**\n1. Use a stack to track valid scores\n2. Process each operation: integer, '+', 'D', 'C'\n3. Handle special operations based on previous scores\n4. Sum all remaining scores in the stack\n\n**Time Complexity:** O(n) - process each operation once\n**Space Complexity:** O(n) - stack storage for scores\n\n**Key Insights:**\n- Stack naturally handles the scoring requirements\n- '+' uses last two scores, 'D' doubles last score\n- 'C' removes the most recent score",
      "solution_code": "def baseballGame(ops):\n    stack = []\n    \n    for op in ops:\n        if op == '+' and len(stack) >= 2:\n            # Sum of previous two scores\n            new_score = stack[-1] + stack[-2]\n            stack.append(new_score)\n        elif op == 'D' and stack:\n            # Double the previous score\n            new_score = stack[-1] * 2\n            stack.append(new_score)\n        elif op == 'C' and stack:\n            # Cancel/remove the previous score\n            stack.pop()\n        else:\n            # Integer score\n            try:\n                score = int(op)\n                stack.append(score)\n            except ValueError:\n                pass  # Invalid operation, skip\n    \n    return sum(stack)"
    },
    "javascript": {
      "template": "function baseballGame(ops) {\n  \n}",
      "solution_text": "Baseball game scoring with stack operations:\n\n**Algorithm:**\n1. Use a stack to track valid scores\n2. Process each operation: integer, '+', 'D', 'C'\n3. Handle special operations based on previous scores\n4. Sum all remaining scores in the stack\n\n**Time Complexity:** O(n) - process each operation once\n**Space Complexity:** O(n) - stack storage for scores\n\n**Key Insights:**\n- Stack naturally handles the scoring requirements\n- '+' uses last two scores, 'D' doubles last score\n- 'C' removes the most recent score",
      "solution_code": "function baseballGame(ops) {\n    const stack = [];\n    \n    for (const op of ops) {\n        if (op === '+' && stack.length >= 2) {\n            // Sum of previous two scores\n            const newScore = stack[stack.length - 1] + stack[stack.length - 2];\n            stack.push(newScore);\n        } else if (op === 'D' && stack.length > 0) {\n            // Double the previous score\n            const newScore = stack[stack.length - 1] * 2;\n            stack.push(newScore);\n        } else if (op === 'C' && stack.length > 0) {\n            // Cancel/remove the previous score\n            stack.pop();\n        } else {\n            // Integer score\n            const score = parseInt(op);\n            if (!isNaN(score)) {\n                stack.push(score);\n            }\n        }\n    }\n    \n    return stack.reduce((sum, score) => sum + score, 0);\n}"
    },
    "typescript": {
      "template": "function baseballGame(ops: string[]): number {\n  \n}",
      "solution_text": "Baseball game scoring with stack operations:\n\n**Algorithm:**\n1. Use a stack to track valid scores\n2. Process each operation: integer, '+', 'D', 'C'\n3. Handle special operations based on previous scores\n4. Sum all remaining scores in the stack\n\n**Time Complexity:** O(n) - process each operation once\n**Space Complexity:** O(n) - stack storage for scores\n\n**Key Insights:**\n- Stack naturally handles the scoring requirements\n- '+' uses last two scores, 'D' doubles last score\n- 'C' removes the most recent score",
      "solution_code": "function baseballGame(ops: string[]): number {\n    const stack: number[] = [];\n    \n    for (const op of ops) {\n        if (op === '+' && stack.length >= 2) {\n            // Sum of previous two scores\n            const newScore = stack[stack.length - 1] + stack[stack.length - 2];\n            stack.push(newScore);\n        } else if (op === 'D' && stack.length > 0) {\n            // Double the previous score\n            const newScore = stack[stack.length - 1] * 2;\n            stack.push(newScore);\n        } else if (op === 'C' && stack.length > 0) {\n            // Cancel/remove the previous score\n            stack.pop();\n        } else {\n            // Integer score\n            const score = parseInt(op);\n            if (!isNaN(score)) {\n                stack.push(score);\n            }\n        }\n    }\n    \n    return stack.reduce((sum, score) => sum + score, 0);\n}"
    },
    "java": {
      "template": "class Solution {\n    public int calPoints(String[] ops) {\n        \n    }\n}",
      "solution_text": "Baseball game scoring with stack operations:\n\n**Algorithm:**\n1. Use a stack to track valid scores\n2. Process each operation: integer, '+', 'D', 'C'\n3. Handle special operations based on previous scores\n4. Sum all remaining scores in the stack\n\n**Time Complexity:** O(n) - process each operation once\n**Space Complexity:** O(n) - stack storage for scores\n\n**Key Insights:**\n- Stack naturally handles the scoring requirements\n- '+' uses last two scores, 'D' doubles last score\n- 'C' removes the most recent score",
      "solution_code": "class Solution {\n    public int calPoints(String[] ops) {\n        Stack<Integer> stack = new Stack<>();\n        \n        for (String op : ops) {\n            if (op.equals(\"+\") && stack.size() >= 2) {\n                // Sum of previous two scores\n                int prev1 = stack.get(stack.size() - 1);\n                int prev2 = stack.get(stack.size() - 2);\n                stack.push(prev1 + prev2);\n            } else if (op.equals(\"D\") && !stack.isEmpty()) {\n                // Double the previous score\n                stack.push(stack.peek() * 2);\n            } else if (op.equals(\"C\") && !stack.isEmpty()) {\n                // Cancel/remove the previous score\n                stack.pop();\n            } else {\n                // Integer score\n                try {\n                    int score = Integer.parseInt(op);\n                    stack.push(score);\n                } catch (NumberFormatException e) {\n                    // Invalid operation, skip\n                }\n            }\n        }\n        \n        int sum = 0;\n        for (int score : stack) {\n            sum += score;\n        }\n        return sum;\n    }\n}"
    }
  },
  "order_matters": false,
  "test_cases": [
    {
      "id": 1,
      "input": {
        "ops": [
          "1",
          "2",
          "+",
          "C",
          "5",
          "D"
        ]
      },
      "output": 18
    },
    {
      "id": 2,
      "input": {
        "ops": [
          "5",
          "D",
          "+",
          "C"
        ]
      },
      "output": 15
    }
  ]
}