{
  "filename": "binary-tree-diameter",
  "title": "Diameter of Binary Tree",
  "keywords": [
    "diameter",
    "binary",
    "tree",
    "leetcode",
    "543",
    "defined",
    "length",
    "longest",
    "path",
    "between"
  ],
  "description": "<h2>Diameter of Binary Tree</h2><p>Leetcode 543. Diameter of Binary Tree</p><p></p><p>The **diameter** of a binary tree is defined as the **length** of the longest path between *any two nodes within the tree*. The path does not necessarily have to pass through the root.</p><p>    </p><p>The **length** of a path between two nodes in a binary tree is the number of edges between the nodes. Note that the path can *not* include the same node twice.</p><p></p><p>Given the root of a binary tree `root`, return the **diameter** of the tree.</p><h3>Examples:</h3><ul><li>Input: root = [1,2,3]<br><br>Output: 2</li></ul><h3>Constraints:</h3><ul><li> `1 <= number of nodes in the tree <= 100`</li><li> `-100 <= Node.val <= 100`</li></ul>",
  "languages": {
    "python": {
      "template": "def diameterOfBinaryTree(root):\n    ",
      "solution_text": "Find diameter of binary tree (longest path between any two nodes):\n\n**Algorithm:**\n1. Use DFS to calculate depth of each subtree\n2. For each node, diameter through it = left_depth + right_depth\n3. Track maximum diameter seen across all nodes\n4. Return depth + 1 for parent nodes\n\n**Time Complexity:** O(n) - visit each node once\n**Space Complexity:** O(h) - recursion stack depth\n\n**Key Insights:**\n- Diameter may or may not pass through root\n- Combine depth calculation with diameter tracking\n- Path length is number of edges, not nodes",
      "solution_code": "# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef diameterOfBinaryTree(root):\n    max_diameter = 0\n    \n    def depth(node):\n        nonlocal max_diameter\n        \n        if not node:\n            return 0\n        \n        # Get depth of left and right subtrees\n        left_depth = depth(node.left)\n        right_depth = depth(node.right)\n        \n        # Update maximum diameter (path through current node)\n        current_diameter = left_depth + right_depth\n        max_diameter = max(max_diameter, current_diameter)\n        \n        # Return depth of current subtree\n        return max(left_depth, right_depth) + 1\n    \n    depth(root)\n    return max_diameter"
    },
    "javascript": {
      "template": "function diameterOfBinaryTree(root) {\n  \n}",
      "solution_text": "Find diameter of binary tree (longest path between any two nodes):\n\n**Algorithm:**\n1. Use DFS to calculate depth of each subtree\n2. For each node, diameter through it = left_depth + right_depth\n3. Track maximum diameter seen across all nodes\n4. Return depth + 1 for parent nodes\n\n**Time Complexity:** O(n) - visit each node once\n**Space Complexity:** O(h) - recursion stack depth\n\n**Key Insights:**\n- Diameter may or may not pass through root\n- Combine depth calculation with diameter tracking\n- Path length is number of edges, not nodes",
      "solution_code": "// Definition for a binary tree node.\nfunction TreeNode(val, left, right) {\n    this.val = (val===undefined ? 0 : val);\n    this.left = (left===undefined ? null : left);\n    this.right = (right===undefined ? null : right);\n}\n\nfunction diameterOfBinaryTree(root) {\n    let maxDiameter = 0;\n    \n    function depth(node) {\n        if (!node) return 0;\n        \n        // Get depth of left and right subtrees\n        const leftDepth = depth(node.left);\n        const rightDepth = depth(node.right);\n        \n        // Update maximum diameter (path through current node)\n        const currentDiameter = leftDepth + rightDepth;\n        maxDiameter = Math.max(maxDiameter, currentDiameter);\n        \n        // Return depth of current subtree\n        return Math.max(leftDepth, rightDepth) + 1;\n    }\n    \n    depth(root);\n    return maxDiameter;\n}"
    },
    "typescript": {
      "template": "function diameterOfBinaryTree(root: TreeNode | null): number {\n  \n}",
      "solution_text": "Find diameter of binary tree (longest path between any two nodes):\n\n**Algorithm:**\n1. Use DFS to calculate depth of each subtree\n2. For each node, diameter through it = left_depth + right_depth\n3. Track maximum diameter seen across all nodes\n4. Return depth + 1 for parent nodes\n\n**Time Complexity:** O(n) - visit each node once\n**Space Complexity:** O(h) - recursion stack depth\n\n**Key Insights:**\n- Diameter may or may not pass through root\n- Combine depth calculation with diameter tracking\n- Path length is number of edges, not nodes",
      "solution_code": "// Definition for a binary tree node.\nclass TreeNode {\n    val: number;\n    left: TreeNode | null;\n    right: TreeNode | null;\n    constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n        this.val = (val===undefined ? 0 : val);\n        this.left = (left===undefined ? null : left);\n        this.right = (right===undefined ? null : right);\n    }\n}\n\nfunction diameterOfBinaryTree(root: TreeNode | null): number {\n    let maxDiameter = 0;\n    \n    function depth(node: TreeNode | null): number {\n        if (!node) return 0;\n        \n        // Get depth of left and right subtrees\n        const leftDepth = depth(node.left);\n        const rightDepth = depth(node.right);\n        \n        // Update maximum diameter (path through current node)\n        const currentDiameter = leftDepth + rightDepth;\n        maxDiameter = Math.max(maxDiameter, currentDiameter);\n        \n        // Return depth of current subtree\n        return Math.max(leftDepth, rightDepth) + 1;\n    }\n    \n    depth(root);\n    return maxDiameter;\n}"
    },
    "java": {
      "template": "class Solution {\n    public int diameterOfBinaryTree(TreeNode root) {\n        \n    }\n}",
      "solution_text": "Find diameter of binary tree (longest path between any two nodes):\n\n**Algorithm:**\n1. Use DFS to calculate depth of each subtree\n2. For each node, diameter through it = left_depth + right_depth\n3. Track maximum diameter seen across all nodes\n4. Return depth + 1 for parent nodes\n\n**Time Complexity:** O(n) - visit each node once\n**Space Complexity:** O(h) - recursion stack depth\n\n**Key Insights:**\n- Diameter may or may not pass through root\n- Combine depth calculation with diameter tracking\n- Path length is number of edges, not nodes",
      "solution_code": "// Definition for a binary tree node.\nclass TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    TreeNode() {}\n    TreeNode(int val) { this.val = val; }\n    TreeNode(int val, TreeNode left, TreeNode right) {\n        this.val = val;\n        this.left = left;\n        this.right = right;\n    }\n}\n\nclass Solution {\n    private int maxDiameter = 0;\n    \n    public int diameterOfBinaryTree(TreeNode root) {\n        maxDiameter = 0;\n        depth(root);\n        return maxDiameter;\n    }\n    \n    private int depth(TreeNode node) {\n        if (node == null) return 0;\n        \n        // Get depth of left and right subtrees\n        int leftDepth = depth(node.left);\n        int rightDepth = depth(node.right);\n        \n        // Update maximum diameter (path through current node)\n        int currentDiameter = leftDepth + rightDepth;\n        maxDiameter = Math.max(maxDiameter, currentDiameter);\n        \n        // Return depth of current subtree\n        return Math.max(leftDepth, rightDepth) + 1;\n    }\n}"
    }
  },
  "order_matters": false,
  "test_cases": [
    {
      "id": 1,
      "input": {
        "root": [
          1,
          2,
          3
        ]
      },
      "output": 2
    }
  ]
}