{
  "filename": "min-cost-climbing-stairs",
  "title": "Min Cost Climbing Stairs",
  "keywords": [
    "min",
    "cost",
    "climbing",
    "stairs",
    "leetcode",
    "746",
    "given",
    "array",
    "integers",
    "where"
  ],
  "description": "<h2>Min Cost Climbing Stairs</h2><p>Leetcode 746. Min Cost Climbing Stairs</p><p></p><p>You are given an array of integers `cost` where `cost[i]` is the cost of taking a step from the `ith` floor of a staircase. After paying the cost, you can step to either the `(i + 1)th` floor or the `(i + 2)th` floor.</p><p></p><p>You may choose to start at the index `0` or the index `1` floor.</p><p></p><p>Return the minimum cost to reach the top of the staircase, i.e. just past the last index in `cost`.</p><h3>Examples:</h3><ul><li>Input: cost = [1,2,3]<br><br>Output: 2<br>We can start at index = `1` and pay the cost of `cost[1] = 2` and take two steps to reach the top. The total cost is `2`.</li><li>Input: cost = [1,2,1,2,1,1,1]<br><br>Output: 4<br>Start at index = `0`.\n* Pay the cost of `cost[0] = 1` and take two steps to reach index = `2`.\n* Pay the cost of `cost[2] = 1` and take two steps to reach index = `4`.\n* Pay the cost of `cost[4] = 1` and take two steps to reach index = `6`.\n* Pay the cost of `cost[6] = 1` and take one step to reach the top.\n* The total cost is `4`.</li></ul><h3>Constraints:</h3><ul><li> `2 <= cost.length <= 100`</li><li> `0 <= cost[i] <= 100`</li></ul>",
  "languages": {
    "python": {
      "template": "def minCostClimbingStairs(cost):\n    ",
      "solution_text": "Dynamic Programming solution with memoization:\n\n**Algorithm:**\n1. Identify overlapping subproblems\n2. Define state and recurrence relation\n3. Use memoization to avoid recomputation\n4. Build solution bottom-up or top-down\n\n**Time Complexity:** O(n) with memoization\n**Space Complexity:** O(n) for memoization table\n\n**Key Insights:**\n- Break problem into smaller subproblems\n- Optimal substructure property\n- Memoization prevents redundant calculations",
      "solution_code": "def minCostClimbingStairs(n):\n    if n <= 0:\n        return 0\n    if n == 1:\n        return 1\n    \n    # Memoization table\n    dp = [-1] * (n + 1)\n    dp[0] = 0\n    dp[1] = 1\n    \n    def solve(i):\n        if dp[i] != -1:\n            return dp[i]\n        \n        # Recurrence relation (adjust based on problem)\n        dp[i] = solve(i - 1) + solve(i - 2)\n        return dp[i]\n    \n    return solve(n)"
    },
    "javascript": {
      "template": "function minCostClimbingStairs(cost) {\n  \n}",
      "solution_text": "Dynamic Programming solution with memoization:\n\n**Algorithm:**\n1. Identify overlapping subproblems\n2. Define state and recurrence relation\n3. Use memoization to avoid recomputation\n4. Build solution bottom-up or top-down\n\n**Time Complexity:** O(n) with memoization\n**Space Complexity:** O(n) for memoization table\n\n**Key Insights:**\n- Break problem into smaller subproblems\n- Optimal substructure property\n- Memoization prevents redundant calculations",
      "solution_code": "function minCostClimbingStairs(n) {\n    if (n <= 0) return 0;\n    if (n === 1) return 1;\n    \n    // Memoization table\n    const dp = new Array(n + 1).fill(-1);\n    dp[0] = 0;\n    dp[1] = 1;\n    \n    function solve(i) {\n        if (dp[i] !== -1) return dp[i];\n        \n        // Recurrence relation (adjust based on problem)\n        dp[i] = solve(i - 1) + solve(i - 2);\n        return dp[i];\n    }\n    \n    return solve(n);\n}"
    },
    "typescript": {
      "template": "function minCostClimbingStairs(cost: number[]): number {\n  \n}",
      "solution_text": "Dynamic Programming solution with memoization:\n\n**Algorithm:**\n1. Identify overlapping subproblems\n2. Define state and recurrence relation\n3. Use memoization to avoid recomputation\n4. Build solution bottom-up or top-down\n\n**Time Complexity:** O(n) with memoization\n**Space Complexity:** O(n) for memoization table\n\n**Key Insights:**\n- Break problem into smaller subproblems\n- Optimal substructure property\n- Memoization prevents redundant calculations",
      "solution_code": "function minCostClimbingStairs(n: number): number {\n    if (n <= 0) return 0;\n    if (n === 1) return 1;\n    \n    // Memoization table\n    const dp: number[] = new Array(n + 1).fill(-1);\n    dp[0] = 0;\n    dp[1] = 1;\n    \n    function solve(i: number): number {\n        if (dp[i] !== -1) return dp[i];\n        \n        // Recurrence relation (adjust based on problem)\n        dp[i] = solve(i - 1) + solve(i - 2);\n        return dp[i];\n    }\n    \n    return solve(n);\n}"
    },
    "java": {
      "template": "class Solution {\n    public int minCostClimbingStairs(int[] cost) {\n        \n    }\n}",
      "solution_text": "Dynamic Programming solution with memoization:\n\n**Algorithm:**\n1. Identify overlapping subproblems\n2. Define state and recurrence relation\n3. Use memoization to avoid recomputation\n4. Build solution bottom-up or top-down\n\n**Time Complexity:** O(n) with memoization\n**Space Complexity:** O(n) for memoization table\n\n**Key Insights:**\n- Break problem into smaller subproblems\n- Optimal substructure property\n- Memoization prevents redundant calculations",
      "solution_code": "class Solution {\n    public int minCostClimbingStairs(int n) {\n        if (n <= 0) return 0;\n        if (n == 1) return 1;\n        \n        // Memoization table\n        int[] dp = new int[n + 1];\n        Arrays.fill(dp, -1);\n        dp[0] = 0;\n        dp[1] = 1;\n        \n        return solve(n, dp);\n    }\n    \n    private int solve(int i, int[] dp) {\n        if (dp[i] != -1) return dp[i];\n        \n        // Recurrence relation (adjust based on problem)\n        dp[i] = solve(i - 1, dp) + solve(i - 2, dp);\n        return dp[i];\n    }\n}"
    }
  },
  "order_matters": false,
  "test_cases": [
    {
      "id": 1,
      "input": {
        "cost": [
          1,
          2,
          3
        ]
      },
      "output": 2
    },
    {
      "id": 2,
      "input": {
        "cost": [
          1,
          2,
          1,
          2,
          1,
          1,
          1
        ]
      },
      "output": 4
    }
  ]
}