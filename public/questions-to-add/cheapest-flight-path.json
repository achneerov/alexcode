{
  "filename": "cheapest-flight-path",
  "title": "Cheapest Flights Within K Stops",
  "keywords": [
    "cheapest",
    "flights",
    "within",
    "stops",
    "leetcode",
    "787",
    "there",
    "airports",
    "labeled",
    "which"
  ],
  "description": "<h2>Cheapest Flights Within K Stops</h2><p>Leetcode 787. Cheapest Flights Within K Stops</p><p></p><p>There are `n` airports, labeled from `0` to `n - 1`, which are connected by some flights. You are given an array `flights` where `flights[i] = [from_i, to_i, price_i]` represents a one-way flight from airport `from_i` to airport `to_i` with cost `price_i`. You may assume there are no duplicate flights and no flights from an airport to itself.</p><p></p><p>You are also given three integers `src`, `dst`, and `k` where:</p><p></p><p>* `src` is the starting airport</p><p>* `dst` is the destination airport</p><p>* `src != dst`</p><p>* `k` is the maximum number of stops you can make (not including `src` and `dst`)</p><p></p><p>Return **the cheapest price** from `src` to `dst` with at most `k` stops, or return `-1` if it is impossible.</p><h3>Constraints:</h3><ul><li> `1 <= n <= 100`</li><li> `fromi != toi`</li><li> `1 <= pricei <= 1000`</li><li> `0 <= src, dst, k < n`</li></ul>",
  "languages": {
    "python": {
      "template": "def cheapestFlightsWithinKStops(n, flights, src, dst, k):\n    ",
      "solution_text": "<p><strong>Cheapest Flights using Bellman-Ford Algorithm:</strong></p><p>Find shortest path with at most k+1 edges (k stops plus final destination).</p><p><strong>Algorithm:</strong></p><ol><li>Use modified Bellman-Ford algorithm with limited iterations</li><li>Initialize distances: src = 0, all others = infinity</li><li>For each iteration (up to k+1), relax all edges</li><li>Track previous distances to avoid using updated values in same iteration</li></ol><p><strong>Key Insight:</strong> We need at most k+1 edges to reach destination with k stops</p><p><strong>Time Complexity:</strong> O(k * E) where E is number of flights</p><p><strong>Space Complexity:</strong> O(n) for distance arrays</p>",
      "solution_code": "def cheapestFlightsWithinKStops(n, flights, src, dst, k):\n    # Initialize distances with infinity, except source\n    dist = [float('inf')] * n\n    dist[src] = 0\n    \n    # Bellman-Ford with at most k+1 iterations (k stops + destination)\n    for _ in range(k + 1):\n        # Use previous distances to avoid using updated values\n        prev_dist = dist[:]\n        \n        for u, v, price in flights:\n            if prev_dist[u] != float('inf'):\n                dist[v] = min(dist[v], prev_dist[u] + price)\n    \n    return dist[dst] if dist[dst] != float('inf') else -1"
    },
    "javascript": {
      "template": "function cheapestFlightsWithinKStops(n, flights, src, dst, k) {\n  \n}",
      "solution_text": "<p><strong>Cheapest Flights using Bellman-Ford Algorithm:</strong></p><p>Find shortest path with at most k+1 edges (k stops plus final destination).</p><p><strong>Algorithm:</strong></p><ol><li>Use modified Bellman-Ford algorithm with limited iterations</li><li>Initialize distances: src = 0, all others = infinity</li><li>For each iteration (up to k+1), relax all edges</li><li>Track previous distances to avoid using updated values in same iteration</li></ol><p><strong>Key Insight:</strong> We need at most k+1 edges to reach destination with k stops</p><p><strong>Time Complexity:</strong> O(k * E) where E is number of flights</p><p><strong>Space Complexity:</strong> O(n) for distance arrays</p>",
      "solution_code": "function cheapestFlightsWithinKStops(n, flights, src, dst, k) {\n    // Initialize distances with infinity, except source\n    const dist = new Array(n).fill(Infinity);\n    dist[src] = 0;\n    \n    // Bellman-Ford with at most k+1 iterations (k stops + destination)\n    for (let i = 0; i <= k; i++) {\n        // Use previous distances to avoid using updated values\n        const prevDist = [...dist];\n        \n        for (const [u, v, price] of flights) {\n            if (prevDist[u] !== Infinity) {\n                dist[v] = Math.min(dist[v], prevDist[u] + price);\n            }\n        }\n    }\n    \n    return dist[dst] === Infinity ? -1 : dist[dst];\n}"
    },
    "typescript": {
      "template": "function cheapestFlightsWithinKStops(n: number, flights: number[][], src: number, dst: number, k: number): number {\n  \n}",
      "solution_text": "<p><strong>Cheapest Flights using Bellman-Ford Algorithm:</strong></p><p>Find shortest path with at most k+1 edges (k stops plus final destination).</p><p><strong>Algorithm:</strong></p><ol><li>Use modified Bellman-Ford algorithm with limited iterations</li><li>Initialize distances: src = 0, all others = infinity</li><li>For each iteration (up to k+1), relax all edges</li><li>Track previous distances to avoid using updated values in same iteration</li></ol><p><strong>Key Insight:</strong> We need at most k+1 edges to reach destination with k stops</p><p><strong>Time Complexity:</strong> O(k * E) where E is number of flights</p><p><strong>Space Complexity:</strong> O(n) for distance arrays</p>",
      "solution_code": "function cheapestFlightsWithinKStops(n: number, flights: number[][], src: number, dst: number, k: number): number {\n    // Initialize distances with infinity, except source\n    const dist: number[] = new Array(n).fill(Infinity);\n    dist[src] = 0;\n    \n    // Bellman-Ford with at most k+1 iterations (k stops + destination)\n    for (let i = 0; i <= k; i++) {\n        // Use previous distances to avoid using updated values\n        const prevDist: number[] = [...dist];\n        \n        for (const [u, v, price] of flights) {\n            if (prevDist[u] !== Infinity) {\n                dist[v] = Math.min(dist[v], prevDist[u] + price);\n            }\n        }\n    }\n    \n    return dist[dst] === Infinity ? -1 : dist[dst];\n}"
    },
    "java": {
      "template": "class Solution {\n    public int cheapestFlightsWithinKStops(int n, int[][] flights, int src, int dst, int k) {\n        \n    }\n}",
      "solution_text": "<p><strong>Cheapest Flights using Bellman-Ford Algorithm:</strong></p><p>Find shortest path with at most k+1 edges (k stops plus final destination).</p><p><strong>Algorithm:</strong></p><ol><li>Use modified Bellman-Ford algorithm with limited iterations</li><li>Initialize distances: src = 0, all others = infinity</li><li>For each iteration (up to k+1), relax all edges</li><li>Track previous distances to avoid using updated values in same iteration</li></ol><p><strong>Key Insight:</strong> We need at most k+1 edges to reach destination with k stops</p><p><strong>Time Complexity:</strong> O(k * E) where E is number of flights</p><p><strong>Space Complexity:</strong> O(n) for distance arrays</p>",
      "solution_code": "class Solution {\n    public int cheapestFlightsWithinKStops(int n, int[][] flights, int src, int dst, int k) {\n        // Initialize distances with infinity, except source\n        int[] dist = new int[n];\n        Arrays.fill(dist, Integer.MAX_VALUE);\n        dist[src] = 0;\n        \n        // Bellman-Ford with at most k+1 iterations (k stops + destination)\n        for (int i = 0; i <= k; i++) {\n            // Use previous distances to avoid using updated values\n            int[] prevDist = dist.clone();\n            \n            for (int[] flight : flights) {\n                int u = flight[0], v = flight[1], price = flight[2];\n                if (prevDist[u] != Integer.MAX_VALUE) {\n                    dist[v] = Math.min(dist[v], prevDist[u] + price);\n                }\n            }\n        }\n        \n        return dist[dst] == Integer.MAX_VALUE ? -1 : dist[dst];\n    }\n}"
    }
  },
  "order_matters": false,
  "test_cases": [
    {
      "id": 1,
      "input": {
        "n": 3,
        "flights": [[0,1,100],[1,2,100],[0,2,500]],
        "src": 0,
        "dst": 2,
        "k": 1
      },
      "output": 200
    },
    {
      "id": 2,
      "input": {
        "n": 3,
        "flights": [[0,1,100],[1,2,100],[0,2,500]],
        "src": 0,
        "dst": 2,
        "k": 0
      },
      "output": 500
    }
  ]
}