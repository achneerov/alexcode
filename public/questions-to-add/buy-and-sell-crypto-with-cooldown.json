{
  "filename": "buy-and-sell-crypto-with-cooldown",
  "title": "Best Time to Buy and Sell Stock with Cooldown",
  "keywords": [
    "best",
    "time",
    "buy",
    "sell",
    "stock",
    "cooldown",
    "leetcode",
    "309",
    "given",
    "integer"
  ],
  "description": "<h2>Best Time to Buy and Sell Stock with Cooldown</h2><p>Leetcode 309. Best Time to Buy And Sell Stock With Cooldown</p><p></p><p>You are given an integer array `prices` where `prices[i]` is the price of NeetCoin on the `ith` day.</p><p></p><p>You may buy and sell one NeetCoin multiple times with the following restrictions:</p><p>* After you sell your NeetCoin, you cannot buy another one on the next day (i.e., there is a cooldown period of one day).</p><p>* You may only own at most one NeetCoin at a time.</p><p></p><p>You may complete as many transactions as you like.</p><p></p><p>Return the **maximum profit** you can achieve.</p><h3>Examples:</h3><ul><li>Input: prices = [1,3,4,0,4]<br><br>Output: 6<br>Buy on day 0 (price = 1) and sell on day 1 (price = 3), profit = 3-1 = 2. Then buy on day 3 (price = 0) and sell on day 4 (price = 4), profit = 4-0 = 4. Total profit is 2 + 4 = 6.</li><li>Input: prices = [1]<br><br>Output: 0</li></ul><h3>Constraints:</h3><ul><li> `1 <= prices.length <= 5000`</li><li> `0 <= prices[i] <= 1000`</li></ul>",
  "languages": {
    "python": {
      "template": "def bestTimeToBuyAndSellStockWithCooldown(prices):\n    ",
      "solution_text": "<p><strong>Dynamic Programming Approach:</strong></p><p>We use dynamic programming to track three states at each day:</p><ul><li><strong>hold</strong>: Maximum profit when holding a stock</li><li><strong>sold</strong>: Maximum profit when just sold (cooldown day)</li><li><strong>rest</strong>: Maximum profit when resting (can buy)</li></ul><p><strong>State Transitions:</strong></p><ul><li>hold[i] = max(hold[i-1], rest[i-1] - prices[i]) - either keep holding or buy today</li><li>sold[i] = hold[i-1] + prices[i] - sell the stock we were holding</li><li>rest[i] = max(rest[i-1], sold[i-1]) - either keep resting or finished cooldown</li></ul><p><strong>Time Complexity:</strong> O(n)</p><p><strong>Space Complexity:</strong> O(1) with optimized variables</p>",
      "solution_code": "def bestTimeToBuyAndSellStockWithCooldown(prices):\n    if not prices or len(prices) <= 1:\n        return 0\n    \n    # State variables: hold (holding stock), sold (just sold), rest (resting)\n    hold = -prices[0]  # Buy on first day\n    sold = 0           # Can't sell on first day\n    rest = 0           # No profit initially\n    \n    for i in range(1, len(prices)):\n        prev_hold = hold\n        prev_sold = sold\n        prev_rest = rest\n        \n        # Update states\n        hold = max(prev_hold, prev_rest - prices[i])  # Keep holding or buy\n        sold = prev_hold + prices[i]                  # Sell stock\n        rest = max(prev_rest, prev_sold)              # Rest or finished cooldown\n    \n    # Return max profit when not holding stock\n    return max(sold, rest)"
    },
    "javascript": {
      "template": "function bestTimeToBuyAndSellStockWithCooldown(prices) {\n  \n}",
      "solution_text": "<p><strong>Dynamic Programming Approach:</strong></p><p>We use dynamic programming to track three states at each day:</p><ul><li><strong>hold</strong>: Maximum profit when holding a stock</li><li><strong>sold</strong>: Maximum profit when just sold (cooldown day)</li><li><strong>rest</strong>: Maximum profit when resting (can buy)</li></ul><p><strong>State Transitions:</strong></p><ul><li>hold[i] = max(hold[i-1], rest[i-1] - prices[i]) - either keep holding or buy today</li><li>sold[i] = hold[i-1] + prices[i] - sell the stock we were holding</li><li>rest[i] = max(rest[i-1], sold[i-1]) - either keep resting or finished cooldown</li></ul><p><strong>Time Complexity:</strong> O(n)</p><p><strong>Space Complexity:</strong> O(1) with optimized variables</p>",
      "solution_code": "function bestTimeToBuyAndSellStockWithCooldown(prices) {\n    if (!prices || prices.length <= 1) {\n        return 0;\n    }\n    \n    // State variables: hold (holding stock), sold (just sold), rest (resting)\n    let hold = -prices[0];  // Buy on first day\n    let sold = 0;           // Can't sell on first day\n    let rest = 0;           // No profit initially\n    \n    for (let i = 1; i < prices.length; i++) {\n        const prevHold = hold;\n        const prevSold = sold;\n        const prevRest = rest;\n        \n        // Update states\n        hold = Math.max(prevHold, prevRest - prices[i]);  // Keep holding or buy\n        sold = prevHold + prices[i];                      // Sell stock\n        rest = Math.max(prevRest, prevSold);              // Rest or finished cooldown\n    }\n    \n    // Return max profit when not holding stock\n    return Math.max(sold, rest);\n}"
    },
    "typescript": {
      "template": "function bestTimeToBuyAndSellStockWithCooldown(prices: number[]): number {\n  \n}",
      "solution_text": "<p><strong>Dynamic Programming Approach:</strong></p><p>We use dynamic programming to track three states at each day:</p><ul><li><strong>hold</strong>: Maximum profit when holding a stock</li><li><strong>sold</strong>: Maximum profit when just sold (cooldown day)</li><li><strong>rest</strong>: Maximum profit when resting (can buy)</li></ul><p><strong>State Transitions:</strong></p><ul><li>hold[i] = max(hold[i-1], rest[i-1] - prices[i]) - either keep holding or buy today</li><li>sold[i] = hold[i-1] + prices[i] - sell the stock we were holding</li><li>rest[i] = max(rest[i-1], sold[i-1]) - either keep resting or finished cooldown</li></ul><p><strong>Time Complexity:</strong> O(n)</p><p><strong>Space Complexity:</strong> O(1) with optimized variables</p>",
      "solution_code": "function bestTimeToBuyAndSellStockWithCooldown(prices: number[]): number {\n    if (!prices || prices.length <= 1) {\n        return 0;\n    }\n    \n    // State variables: hold (holding stock), sold (just sold), rest (resting)\n    let hold: number = -prices[0];  // Buy on first day\n    let sold: number = 0;           // Can't sell on first day\n    let rest: number = 0;           // No profit initially\n    \n    for (let i = 1; i < prices.length; i++) {\n        const prevHold: number = hold;\n        const prevSold: number = sold;\n        const prevRest: number = rest;\n        \n        // Update states\n        hold = Math.max(prevHold, prevRest - prices[i]);  // Keep holding or buy\n        sold = prevHold + prices[i];                      // Sell stock\n        rest = Math.max(prevRest, prevSold);              // Rest or finished cooldown\n    }\n    \n    // Return max profit when not holding stock\n    return Math.max(sold, rest);\n}"
    },
    "java": {
      "template": "class Solution {\n    public int bestTimeToBuyAndSellStockWithCooldown(int[] prices) {\n        \n    }\n}",
      "solution_text": "<p><strong>Dynamic Programming Approach:</strong></p><p>We use dynamic programming to track three states at each day:</p><ul><li><strong>hold</strong>: Maximum profit when holding a stock</li><li><strong>sold</strong>: Maximum profit when just sold (cooldown day)</li><li><strong>rest</strong>: Maximum profit when resting (can buy)</li></ul><p><strong>State Transitions:</strong></p><ul><li>hold[i] = max(hold[i-1], rest[i-1] - prices[i]) - either keep holding or buy today</li><li>sold[i] = hold[i-1] + prices[i] - sell the stock we were holding</li><li>rest[i] = max(rest[i-1], sold[i-1]) - either keep resting or finished cooldown</li></ul><p><strong>Time Complexity:</strong> O(n)</p><p><strong>Space Complexity:</strong> O(1) with optimized variables</p>",
      "solution_code": "class Solution {\n    public int bestTimeToBuyAndSellStockWithCooldown(int[] prices) {\n        if (prices == null || prices.length <= 1) {\n            return 0;\n        }\n        \n        // State variables: hold (holding stock), sold (just sold), rest (resting)\n        int hold = -prices[0];  // Buy on first day\n        int sold = 0;           // Can't sell on first day\n        int rest = 0;           // No profit initially\n        \n        for (int i = 1; i < prices.length; i++) {\n            int prevHold = hold;\n            int prevSold = sold;\n            int prevRest = rest;\n            \n            // Update states\n            hold = Math.max(prevHold, prevRest - prices[i]);  // Keep holding or buy\n            sold = prevHold + prices[i];                      // Sell stock\n            rest = Math.max(prevRest, prevSold);              // Rest or finished cooldown\n        }\n        \n        // Return max profit when not holding stock\n        return Math.max(sold, rest);\n    }\n}"
    }
  },
  "order_matters": false,
  "test_cases": [
    {
      "id": 1,
      "input": {
        "prices": [
          1,
          3,
          4,
          0,
          4
        ]
      },
      "output": 6
    },
    {
      "id": 2,
      "input": {
        "prices": [
          1
        ]
      },
      "output": 0
    }
  ]
}