{
  "filename": "coin-change-ii",
  "title": "Coin Change II",
  "keywords": [
    "coin",
    "change",
    "leetcode",
    "518",
    "given",
    "integer",
    "array",
    "coins",
    "representing",
    "different"
  ],
  "description": "<h2>Coin Change II</h2><p>Leetcode 518. Coin Change II</p><p></p><p>You are given an integer array `coins` representing coins of different denominations (e.g. 1 dollar, 5 dollars, etc) and an integer `amount` representing a target amount of money.</p><p></p><p>Return the number of distinct combinations that total up to `amount`. If it's impossible to make up the amount, return `0`.</p><p></p><p>You may assume that you have an unlimited number of each coin and that each value in `coins` is unique.</p><h3>Examples:</h3><ul><li>Input: amount = 4, coins = [1,2,3]<br><br>Output: 4<br>* 1+1+1+1 = 4\n* 1+1+2 = 4\n* 2+2 = 4\n* 1+3 = 4</li><li>Input: amount = 7, coins = [2,4]<br><br>Output: 0</li></ul><h3>Constraints:</h3><ul><li> `1 <= coins.length <= 100`</li><li> `1 <= coins[i] <= 5000`</li><li> `0 <= amount <= 5000`</li></ul>",
  "languages": {
    "python": {
      "template": "def coinChangeIi(amount, coins):\n    ",
      "solution_text": "<h3>Coin Change II</h3><p><strong>Algorithm:</strong></p><ol><li>Use 2D DP where dp[i][j] = ways to make amount j using first i coins</li><li>For each coin, we can either include it or exclude it</li><li>If we include coin, subtract its value and add ways from previous amount</li><li>If we exclude coin, take ways from previous coin index</li><li>Optimize to 1D DP by processing coins in order</li></ol><p><strong>Time Complexity:</strong> O(amount × coins.length) - fill DP table</p><p><strong>Space Complexity:</strong> O(amount) - 1D DP array optimization</p><p><strong>Key Insights:</strong></p><ul><li>This is a combination problem, not permutation (order doesn't matter)</li><li>Process coins in order to avoid duplicate combinations</li><li>Base case: dp[0] = 1 (one way to make amount 0 - use no coins)</li></ul>",
      "solution_code": "def coinChangeIi(amount, coins):\n    # dp[i] = number of ways to make amount i\n    dp = [0] * (amount + 1)\n    dp[0] = 1  # One way to make amount 0: use no coins\n    \n    # Process each coin\n    for coin in coins:\n        # Update dp array for this coin\n        for i in range(coin, amount + 1):\n            dp[i] += dp[i - coin]\n    \n    return dp[amount]"
    },
    "javascript": {
      "template": "function coinChangeIi(amount, coins) {\n  \n}",
      "solution_text": "<h3>Coin Change II</h3><p><strong>Algorithm:</strong></p><ol><li>Use 2D DP where dp[i][j] = ways to make amount j using first i coins</li><li>For each coin, we can either include it or exclude it</li><li>If we include coin, subtract its value and add ways from previous amount</li><li>If we exclude coin, take ways from previous coin index</li><li>Optimize to 1D DP by processing coins in order</li></ol><p><strong>Time Complexity:</strong> O(amount × coins.length) - fill DP table</p><p><strong>Space Complexity:</strong> O(amount) - 1D DP array optimization</p><p><strong>Key Insights:</strong></p><ul><li>This is a combination problem, not permutation (order doesn't matter)</li><li>Process coins in order to avoid duplicate combinations</li><li>Base case: dp[0] = 1 (one way to make amount 0 - use no coins)</li></ul>",
      "solution_code": "function coinChangeIi(amount, coins) {\n    // dp[i] = number of ways to make amount i\n    const dp = new Array(amount + 1).fill(0);\n    dp[0] = 1; // One way to make amount 0: use no coins\n    \n    // Process each coin\n    for (const coin of coins) {\n        // Update dp array for this coin\n        for (let i = coin; i <= amount; i++) {\n            dp[i] += dp[i - coin];\n        }\n    }\n    \n    return dp[amount];\n}"
    },
    "typescript": {
      "template": "function coinChangeIi(amount: number, coins: number[]): number {\n  \n}",
      "solution_text": "<h3>Coin Change II</h3><p><strong>Algorithm:</strong></p><ol><li>Use 2D DP where dp[i][j] = ways to make amount j using first i coins</li><li>For each coin, we can either include it or exclude it</li><li>If we include coin, subtract its value and add ways from previous amount</li><li>If we exclude coin, take ways from previous coin index</li><li>Optimize to 1D DP by processing coins in order</li></ol><p><strong>Time Complexity:</strong> O(amount × coins.length) - fill DP table</p><p><strong>Space Complexity:</strong> O(amount) - 1D DP array optimization</p><p><strong>Key Insights:</strong></p><ul><li>This is a combination problem, not permutation (order doesn't matter)</li><li>Process coins in order to avoid duplicate combinations</li><li>Base case: dp[0] = 1 (one way to make amount 0 - use no coins)</li></ul>",
      "solution_code": "function coinChangeIi(amount: number, coins: number[]): number {\n    // dp[i] = number of ways to make amount i\n    const dp: number[] = new Array(amount + 1).fill(0);\n    dp[0] = 1; // One way to make amount 0: use no coins\n    \n    // Process each coin\n    for (const coin of coins) {\n        // Update dp array for this coin\n        for (let i = coin; i <= amount; i++) {\n            dp[i] += dp[i - coin];\n        }\n    }\n    \n    return dp[amount];\n}"
    },
    "java": {
      "template": "class Solution {\n    public int coinChangeIi(int amount, int[] coins) {\n        \n    }\n}",
      "solution_text": "<h3>Coin Change II</h3><p><strong>Algorithm:</strong></p><ol><li>Use 2D DP where dp[i][j] = ways to make amount j using first i coins</li><li>For each coin, we can either include it or exclude it</li><li>If we include coin, subtract its value and add ways from previous amount</li><li>If we exclude coin, take ways from previous coin index</li><li>Optimize to 1D DP by processing coins in order</li></ol><p><strong>Time Complexity:</strong> O(amount × coins.length) - fill DP table</p><p><strong>Space Complexity:</strong> O(amount) - 1D DP array optimization</p><p><strong>Key Insights:</strong></p><ul><li>This is a combination problem, not permutation (order doesn't matter)</li><li>Process coins in order to avoid duplicate combinations</li><li>Base case: dp[0] = 1 (one way to make amount 0 - use no coins)</li></ul>",
      "solution_code": "class Solution {\n    public int coinChangeIi(int amount, int[] coins) {\n        // dp[i] = number of ways to make amount i\n        int[] dp = new int[amount + 1];\n        dp[0] = 1; // One way to make amount 0: use no coins\n        \n        // Process each coin\n        for (int coin : coins) {\n            // Update dp array for this coin\n            for (int i = coin; i <= amount; i++) {\n                dp[i] += dp[i - coin];\n            }\n        }\n        \n        return dp[amount];\n    }\n}"
    }
  },
  "order_matters": false,
  "test_cases": [
    {
      "id": 1,
      "input": {
        "amount": 4,
        "coins": [
          1,
          2,
          3
        ]
      },
      "output": 4
    },
    {
      "id": 2,
      "input": {
        "amount": 7,
        "coins": [
          2,
          4
        ]
      },
      "output": 0
    }
  ]
}