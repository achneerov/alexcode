{
  "filename": "burst-balloons",
  "title": "Burst Balloons",
  "keywords": [
    "burst",
    "balloons",
    "leetcode",
    "312",
    "given",
    "array",
    "integers",
    "nums",
    "size",
    "ith"
  ],
  "description": "<h2>Burst Balloons</h2><p>Leetcode 312. Burst Balloons</p><p></p><p>You are given an array of integers `nums` of size `n`. The `ith` element represents a balloon with an integer value of `nums[i]`. You must burst all of the balloons.</p><p></p><p>If you burst the `ith` balloon, you will receive `nums[i - 1] * nums[i] * nums[i + 1]` coins. If `i - 1` or `i + 1` goes out of bounds of the array, then assume the out of bounds value is 1.</p><p></p><p>Return the maximum number of coins you can receive by bursting all of the balloons.</p><h3>Examples:</h3><ul><li>Input: nums = [4,2,3,7]<br><br>Output: 143<br><br>Explanation:<br>nums = [4,2,3,7] --> [4,3,7] --> [4,7] --> [7] --> []<br>coins =  4*2*3    +   4*3*7   +  1*4*7  + 1*7*1 = 143</li></ul><h3>Constraints:</h3><ul><li> `n == nums.length`</li><li> `1 <= n <= 300`</li><li> `0 <= nums[i] <= 100`</li></ul>",
  "languages": {
    "python": {
      "template": "def burstBalloons(nums):\n    ",
      "solution_text": "<h3>Burst Balloons</h3><p><strong>Algorithm:</strong></p><ol><li>Use dynamic programming with interval DP approach</li><li>Add virtual balloons with value 1 at both ends</li><li>For each interval [i,j], try every possible last balloon k to burst</li><li>dp[i][j] = max coins from bursting all balloons between i and j (exclusive)</li><li>The answer is dp[0][n+1] where n is the original array length</li></ol><p><strong>Time Complexity:</strong> O(n³) - three nested loops for DP</p><p><strong>Space Complexity:</strong> O(n²) - 2D DP table</p><p><strong>Key Insights:</strong></p><ul><li>Think backwards: which balloon to burst last in each interval</li><li>Add dummy balloons to handle boundary conditions</li><li>Interval DP pattern: combine smaller solved subproblems</li></ul>",
      "solution_code": "def burstBalloons(nums):\n    # Add dummy balloons with value 1 at both ends\n    balloons = [1] + nums + [1]\n    n = len(balloons)\n    \n    # dp[i][j] = max coins from bursting balloons between i and j (exclusive)\n    dp = [[0] * n for _ in range(n)]\n    \n    # Length of the interval\n    for length in range(2, n):\n        # Start position\n        for i in range(n - length):\n            j = i + length\n            \n            # Try every balloon k as the last one to burst in interval [i,j]\n            for k in range(i + 1, j):\n                # Coins from bursting balloon k last\n                coins = balloons[i] * balloons[k] * balloons[j]\n                # Total coins = coins from k + left subproblem + right subproblem\n                dp[i][j] = max(dp[i][j], dp[i][k] + coins + dp[k][j])\n    \n    # Return max coins from the entire array (excluding dummy balloons)\n    return dp[0][n - 1]"
    },
    "javascript": {
      "template": "function burstBalloons(nums) {\n  \n}",
      "solution_text": "<h3>Burst Balloons</h3><p><strong>Algorithm:</strong></p><ol><li>Use dynamic programming with interval DP approach</li><li>Add virtual balloons with value 1 at both ends</li><li>For each interval [i,j], try every possible last balloon k to burst</li><li>dp[i][j] = max coins from bursting all balloons between i and j (exclusive)</li><li>The answer is dp[0][n+1] where n is the original array length</li></ol><p><strong>Time Complexity:</strong> O(n³) - three nested loops for DP</p><p><strong>Space Complexity:</strong> O(n²) - 2D DP table</p><p><strong>Key Insights:</strong></p><ul><li>Think backwards: which balloon to burst last in each interval</li><li>Add dummy balloons to handle boundary conditions</li><li>Interval DP pattern: combine smaller solved subproblems</li></ul>",
      "solution_code": "function burstBalloons(nums) {\n    // Add dummy balloons with value 1 at both ends\n    const balloons = [1, ...nums, 1];\n    const n = balloons.length;\n    \n    // dp[i][j] = max coins from bursting balloons between i and j (exclusive)\n    const dp = Array(n).fill().map(() => Array(n).fill(0));\n    \n    // Length of the interval\n    for (let length = 2; length < n; length++) {\n        // Start position\n        for (let i = 0; i < n - length; i++) {\n            const j = i + length;\n            \n            // Try every balloon k as the last one to burst in interval [i,j]\n            for (let k = i + 1; k < j; k++) {\n                // Coins from bursting balloon k last\n                const coins = balloons[i] * balloons[k] * balloons[j];\n                // Total coins = coins from k + left subproblem + right subproblem\n                dp[i][j] = Math.max(dp[i][j], dp[i][k] + coins + dp[k][j]);\n            }\n        }\n    }\n    \n    // Return max coins from the entire array (excluding dummy balloons)\n    return dp[0][n - 1];\n}"
    },
    "typescript": {
      "template": "function burstBalloons(nums: number[]): number {\n  \n}",
      "solution_text": "<h3>Burst Balloons</h3><p><strong>Algorithm:</strong></p><ol><li>Use dynamic programming with interval DP approach</li><li>Add virtual balloons with value 1 at both ends</li><li>For each interval [i,j], try every possible last balloon k to burst</li><li>dp[i][j] = max coins from bursting all balloons between i and j (exclusive)</li><li>The answer is dp[0][n+1] where n is the original array length</li></ol><p><strong>Time Complexity:</strong> O(n³) - three nested loops for DP</p><p><strong>Space Complexity:</strong> O(n²) - 2D DP table</p><p><strong>Key Insights:</strong></p><ul><li>Think backwards: which balloon to burst last in each interval</li><li>Add dummy balloons to handle boundary conditions</li><li>Interval DP pattern: combine smaller solved subproblems</li></ul>",
      "solution_code": "function burstBalloons(nums: number[]): number {\n    // Add dummy balloons with value 1 at both ends\n    const balloons: number[] = [1, ...nums, 1];\n    const n = balloons.length;\n    \n    // dp[i][j] = max coins from bursting balloons between i and j (exclusive)\n    const dp: number[][] = Array(n).fill(0).map(() => Array(n).fill(0));\n    \n    // Length of the interval\n    for (let length = 2; length < n; length++) {\n        // Start position\n        for (let i = 0; i < n - length; i++) {\n            const j = i + length;\n            \n            // Try every balloon k as the last one to burst in interval [i,j]\n            for (let k = i + 1; k < j; k++) {\n                // Coins from bursting balloon k last\n                const coins = balloons[i] * balloons[k] * balloons[j];\n                // Total coins = coins from k + left subproblem + right subproblem\n                dp[i][j] = Math.max(dp[i][j], dp[i][k] + coins + dp[k][j]);\n            }\n        }\n    }\n    \n    // Return max coins from the entire array (excluding dummy balloons)\n    return dp[0][n - 1];\n}"
    },
    "java": {
      "template": "class Solution {\n    public int burstBalloons(int[] nums) {\n        \n    }\n}",
      "solution_text": "<h3>Burst Balloons</h3><p><strong>Algorithm:</strong></p><ol><li>Use dynamic programming with interval DP approach</li><li>Add virtual balloons with value 1 at both ends</li><li>For each interval [i,j], try every possible last balloon k to burst</li><li>dp[i][j] = max coins from bursting all balloons between i and j (exclusive)</li><li>The answer is dp[0][n+1] where n is the original array length</li></ol><p><strong>Time Complexity:</strong> O(n³) - three nested loops for DP</p><p><strong>Space Complexity:</strong> O(n²) - 2D DP table</p><p><strong>Key Insights:</strong></p><ul><li>Think backwards: which balloon to burst last in each interval</li><li>Add dummy balloons to handle boundary conditions</li><li>Interval DP pattern: combine smaller solved subproblems</li></ul>",
      "solution_code": "class Solution {\n    public int burstBalloons(int[] nums) {\n        // Add dummy balloons with value 1 at both ends\n        int[] balloons = new int[nums.length + 2];\n        balloons[0] = 1;\n        balloons[balloons.length - 1] = 1;\n        for (int i = 0; i < nums.length; i++) {\n            balloons[i + 1] = nums[i];\n        }\n        \n        int n = balloons.length;\n        // dp[i][j] = max coins from bursting balloons between i and j (exclusive)\n        int[][] dp = new int[n][n];\n        \n        // Length of the interval\n        for (int length = 2; length < n; length++) {\n            // Start position\n            for (int i = 0; i < n - length; i++) {\n                int j = i + length;\n                \n                // Try every balloon k as the last one to burst in interval [i,j]\n                for (int k = i + 1; k < j; k++) {\n                    // Coins from bursting balloon k last\n                    int coins = balloons[i] * balloons[k] * balloons[j];\n                    // Total coins = coins from k + left subproblem + right subproblem\n                    dp[i][j] = Math.max(dp[i][j], dp[i][k] + coins + dp[k][j]);\n                }\n            }\n        }\n        \n        // Return max coins from the entire array (excluding dummy balloons)\n        return dp[0][n - 1];\n    }\n}"
    }
  },
  "order_matters": false,
  "test_cases": [
    {
      "id": 1,
      "input": {
        "nums": [
          4,
          2,
          3,
          7
        ]
      },
      "output": 143
    }
  ]
}